# AST Data Models and Transformations

This document details the Abstract Syntax Tree representations used in ASN1SCC and how they transform through the compilation pipeline.

## AST Evolution Pipeline

ASN1SCC uses multiple AST representations, each optimized for specific compilation phases:

```
Generic AST (ANTLR) → Parameterized AST → Asn1Ast → Asn1AcnAst → DAst → Code
```

## 1. Generic AST (ANTLR Output)

**Location**: Generated by ANTLR parsers from `Antlr/asn1.g` and `Antlr/acn.g`
**Purpose**: Direct representation of parser output
**Language**: C# (ANTLR runtime)

### Characteristics
- Untyped tree nodes with string-based type identification
- Preserves all syntactic details including whitespace and comments
- Contains both valid and potentially invalid constructs
- Minimal semantic validation

### Example Structure
```csharp
// C# ANTLR tree representation
ITree moduleDefNode = tree.GetChild(0);
string moduleName = moduleDefNode.GetChild(0).Text;
ITree typeAssignments = moduleDefNode.GetChild(1);
```

### Processing Location
**File**: `FrontEndAst/AntlrParse.fs`
```fsharp
let parseAntlrOutput (tree: ITree) : GenericAst =
    // Transform ANTLR C# tree into F# representation
    createAstFromAntlrTree tree
```

## 2. Parameterized AST

**Location**: `FrontEndAst/ParameterizedAsn1Ast.fs`
**Purpose**: Support ASN.1 parameterized types (templates/generics)

### Key Features
```fsharp
type ParameterizedAsn1Ast.Asn1Type = {
    Kind: Asn1TypeKind
    // Parameters like Matrix{rows, cols}
    parameterizedTypeInstance: ParameterizedTypeInstance option
    // Constraints may reference parameters
    Constraints: Asn1Constraint list
    // Source location for error reporting
    Location: SrcLoc
}

type ParameterizedTypeInstance = {
    typeName: string
    parameters: Asn1Value list  // Actual parameter values
}
```

### Example Parameterized Type
```asn1
-- ASN.1 source
Matrix{INTEGER:rows, INTEGER:cols} ::= SEQUENCE (SIZE(rows)) OF SEQUENCE (SIZE(cols)) OF REAL

-- Instantiation
MyMatrix ::= Matrix{10, 20}
```

### Transformation Logic
**File**: `FrontEndAst/CreateAsn1AstFromAntlrTree.fs`
```fsharp
let createParameterizedType (antlrNode: ITree) : ParameterizedAsn1Type =
    match antlrNode.Type with
    | ASN1_TYPE_ASSIGNMENT ->
        // Extract type name and parameters
        // Build parameterized type structure
```

## 3. Template Resolution Phase

**Location**: `FrontEndAst/RemoveParameterizedTypes.fs`
**Purpose**: Resolve template instantiations into concrete types

### Resolution Process
```fsharp
type TemplateResolver = {
    // Map from parameterized type name to definition
    parameterizedTypes: Map<string, ParameterizedAsn1Type>
    // Map from instantiation to resolved type
    instantiations: Map<ParameterizedTypeInstance, Asn1Type>
}

let resolveParameterizedType
    (resolver: TemplateResolver)
    (instance: ParameterizedTypeInstance) : Asn1Type =
    // 1. Look up parameterized definition
    // 2. Substitute parameter values
    // 3. Resolve constraints with substituted values
    // 4. Create concrete type
```

### Example Resolution
```fsharp
// Before resolution
Matrix{10, 20} with parameters [rows=10, cols=20]

// After resolution
SEQUENCE (SIZE(10)) OF SEQUENCE (SIZE(20)) OF REAL
```

**Debugging Location**: When parameterized types fail to resolve, check:
- Parameter count mismatches in `RemoveParameterizedTypes.fs:150-200`
- Type constraint violations in constraint resolution logic

## 4. Core ASN.1 AST (Asn1Ast)

**Location**: `FrontEndAst/Asn1Ast.fs`
**Purpose**: Final, strongly-typed ASN.1 representation without parameters

### Type Hierarchy
```fsharp
type Asn1Type = {
    Kind: Asn1TypeKind
    Constraints: Asn1Constraint list
    Location: SrcLoc
    // Optional field for custom attributes
    acnInfo: unit option  // Filled later in ACN merge phase
}

type Asn1TypeKind =
    | Integer of IntegerType
    | Real of RealType
    | IA5String of StringType
    | Enumerated of EnumeratedType
    | BitString of BitStringType
    | OctetString of OctetStringType
    | Boolean of BooleanType
    | Choice of ChoiceType
    | Sequence of SequenceType
    | SequenceOf of SequenceOfType
    | SetOf of SetOfType
    | ReferenceType of ReferenceToType
```

### Constraint Representation
```fsharp
type Asn1Constraint =
    | SingleValueConstraint of Asn1Value
    | RangeConstraint of (Asn1Value option * Asn1Value option) // min, max
    | SizeConstraint of Asn1Constraint  // SIZE(constraint)
    | AlphabetConstraint of Asn1Constraint
    | UnionConstraint of (Asn1Constraint * Asn1Constraint)
    | IntersectionConstraint of (Asn1Constraint * Asn1Constraint)
    | AllExceptConstraint of Asn1Constraint
    | ExceptConstraint of (Asn1Constraint * Asn1Constraint)
    | RootConstraint of Asn1Constraint
    | RootConstraint2 of (Asn1Constraint * Asn1Constraint)
```

### Complex Type Examples
```fsharp
// SEQUENCE type structure
type SequenceType = {
    children: SequenceChild list
    // Information for PER encoding
    hasAnyOptionalChildOrExtension: bool
}

type SequenceChild =
    | SequenceChildComponent of SequenceChildComponent
    | SequenceChildExtensionMarker

type SequenceChildComponent = {
    name: StringLoc
    chType: Asn1Type
    isOptional: bool
    defaultValue: Asn1Value option
    location: SrcLoc
}
```

## 5. ACN Integration (Asn1AcnAst)

**Location**: `FrontEndAst/Asn1AcnAst.fs`
**Purpose**: Merge ASN.1 structural information with ACN encoding specifications

### Enhanced Type Structure
```fsharp
type Asn1AcnAst.Asn1Type = {
    Kind: Asn1TypeKind
    Constraints: Asn1Constraint list
    Location: SrcLoc
    // ACN encoding information
    acnInfo: AcnTypeInfo
    // Additional encoding parameters
    acnParameters: AcnParameter list
}

type AcnTypeInfo = {
    // Encoding properties like endianness, alignment
    encoding: AcnEncodingSpec option
    // Size specifications
    size: AcnSizeSpec option
    // Presence conditions for optional fields
    presentWhen: AcnPresentWhenCondition option
}
```

### ACN Encoding Specifications
```fsharp
type AcnEncodingSpec =
    | AcnInteger of AcnIntEncodingSpec
    | AcnReal of AcnRealEncodingSpec
    | AcnString of AcnStringEncodingSpec
    | AcnBoolean of AcnBoolEncodingSpec
    | AcnEnum of AcnEnumEncodingSpec

type AcnIntEncodingSpec = {
    endianness: AcnEndianness option
    size: AcnIntSize
    encoding: AcnIntEncoding
}
```

### ACN Processing Files
- **`AcnCreateFromAntlr.fs`** - Parse ACN grammar into F# types
- **`AcnGenericCreateFromAntlr.fs`** - Handle generic ACN specifications
- **`LoadAcnInfo.fs`** - Associate ACN specs with ASN.1 types

## 6. DAst (Backend AST)

**Location**: `FrontEndAst/DAst.fs`
**Purpose**: Backend-ready AST with lambda functions for code generation

### Lambda-Based Architecture
```fsharp
type DAst.Asn1Type = {
    Kind: Asn1TypeKind
    // ... structural information ...

    // Code generation functions
    isValidFunction: IsValidFunction option
    initFunction: InitFunction option
    equalFunction: EqualFunction option
    printValue: PrintValueFunction option

    // Encoding functions
    uperEncodeFunction: UPerEncodeFunction option
    uperDecodeFunction: UPerDecodeFunction option
    acnEncodeFunction: AcnEncodeFunction option
    acnDecodeFunction: AcnDecodeFunction option
    xerEncodeFunction: XerEncodeFunction option
}

type IsValidFunction = {
    funcName: string
    // Lambda that generates validation code
    funcBody: CallerScope -> ValidationStatement list
    // Function for variable declarations needed
    localVariables: LocalVariable list
}
```

### Code Generation Lambda Examples
```fsharp
// Example validation function for INTEGER with range constraint
let integerValidation (scope: CallerScope) : ValidationStatement list =
    [
        CheckStatement {
            condition = sprintf "(%s >= %s && %s <= %s)"
                scope.arg.getValue minVal scope.arg.getValue maxVal
            errCode = "ERR_INTEGER_OUT_OF_RANGE"
        }
    ]

// Example initialization function
let integerInitialization (scope: CallerScope) : InitStatement list =
    [
        AssignStatement {
            lvalue = scope.arg.getValue
            rvalue = "0"  // Default value
        }
    ]
```

### Target Language Abstraction
The lambda functions generate abstract statements that are later transformed to target language syntax:

```fsharp
type ValidationStatement =
    | CheckStatement of CheckInfo
    | LoopStatement of LoopInfo
    | SequenceStatement of ValidationStatement list

type CheckInfo = {
    condition: string           // Abstract condition expression
    errCode: string            // Error code identifier
    nestingLevel: int          // For proper indentation
}
```

## Validation and Error Handling

### Validation Phases
Each AST transformation includes validation:

1. **Syntax Validation** - ANTLR parser catches syntax errors
2. **Structural Validation** - Type construction validation in `CreateAsn1AstFromAntlrTree.fs`
3. **Semantic Validation** - `CheckAsn1.fs` performs comprehensive checks
4. **Constraint Validation** - Range and size constraint checking
5. **Reference Resolution** - Verify all type references are valid

### Error Reporting
```fsharp
type SemanticError = {
    location: SrcLoc
    description: string
    errorType: SemanticErrorType
}

type SrcLoc = {
    srcFilename: string
    line: int
    column: int
}
```

### Common Validation Issues and Locations

**Circular Type Dependencies**:
- **Detection**: `CheckAsn1.fs:checkForCyclicDependencies`
- **Symptoms**: Stack overflow during type resolution
- **Fix**: Look for mutually recursive type definitions

**Constraint Violations**:
- **Detection**: `CommonTypes/RangeSets.fs` and constraint validation
- **Symptoms**: Values outside allowed ranges
- **Fix**: Check constraint logic in type definitions

**Template Resolution Failures**:
- **Detection**: `RemoveParameterizedTypes.fs:resolveTypeInstance`
- **Symptoms**: Unknown parameterized type errors
- **Fix**: Verify parameter count and type compatibility

**ACN-ASN.1 Mismatches**:
- **Detection**: `AcnCreateFromAntlr.fs` and `LoadAcnInfo.fs`
- **Symptoms**: ACN spec references non-existent ASN.1 types
- **Fix**: Check name correspondence between ACN and ASN.1 files

## AST Debugging Tips

### Inspecting AST Structure
Use the XML export feature to examine AST structure:
```bash
asn1scc -x output.xml input.asn1
```

### Common AST-Related Bug Patterns

1. **Null Reference Exceptions**: Usually in Optional field handling
   - Check: Pattern matching on `option` types in F#
   - Location: Type construction functions

2. **Stack Overflow**: Often circular dependencies
   - Check: Type reference resolution
   - Location: `CheckAsn1.fs` dependency analysis

3. **Code Generation Errors**: Lambda function issues
   - Check: Lambda function implementations in DAst construction
   - Location: `BackendAst/DAst*.fs` files

4. **Template Parameter Mismatches**: Wrong parameter count/type
   - Check: Parameter validation in template resolution
   - Location: `RemoveParameterizedTypes.fs`

This multi-stage AST approach allows ASN1SCC to handle complex language features while maintaining clear separation of concerns between parsing, semantic analysis, and code generation.