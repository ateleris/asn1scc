/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group ch ;

rtlModuleName() ::= ""


PrintAutomaticTestCasesSpecFile(sModNameUpperCase, sModName, arrsIncludedModules, arrsTestFunctions) ::= <<
#ifndef GENERATED_ASN1SCC_<sModNameUpperCase>
#define GENERATED_ASN1SCC_<sModNameUpperCase>
/*
Code automatically generated by asn1scc tool
*/
#include "asn1crt.h"
#include "<sModName>.h"

#ifdef  __cplusplus
extern "C" {
#endif


<arrsTestFunctions:{tas|<tas>}; separator="\n\n">



#ifdef  __cplusplus
}
#endif

#endif

>>


PrintAutomaticTestCasesBodyFile(sModName, sTetscaseSpecFileName, arrsIncludedModules, arrsTasNames, arrsTypeAssignments, bXer) ::= <<
/*
Code automatically generated by asn1scc tool
*/

#include \<string.h>
#include \<math.h>
#include \<limits.h>
#include \<stdio.h>
#include "asn1crt.h"
#include "<sTetscaseSpecFileName>"

<arrsIncludedModules: {inc|#include "<inc>.h"}; separator="\n">

<arrsTypeAssignments:{tas|<tas>}; separator="\n">

>>





/* Encode Decode start*/





Codec_Encode(sModName, sFuncName, sVal) ::= <<
// Encode value
ret = <sFuncName>(<sVal>, &bitStrm, pErrCode, TRUE);
*pErrCode = (ret && *pErrCode ==0) ? 0 : 1;
>>

Codec_Decode(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
BitStream_AttachBuffer(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
// Decode value
ret = <sFuncName>(<sAmber>decodedPDU, &bitStrm, pErrCode);
*pErrCode = (ret && *pErrCode ==0) ? 0 : 2;
>>

Codec_Decode_XER(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
ByteStream_AttachBuffer(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
// Decode value
ret = <sFuncName>(<sAmber>decodedPDU, &bitStrm, pErrCode);
*pErrCode = (ret && *pErrCode ==0) ? 0 : 2;
>>

Codec_validate_output(sModName, sFuncName, sAmber) ::= <<
// validate decoded data
ret = <sFuncName>(<sAmber>decodedPDU, pErrCode);
*pErrCode = (ret && *pErrCode ==0) ? 0 : 3;
>>

Codec_compare_input_with_output(sModName, sFuncName, sVal, sAmber) ::= <<
ret = <sFuncName>(<sVal>, <sAmber>decodedPDU);
*pErrCode = ret ? 0 : 4;
>>

Codec_write_CharstreamToFile() ::= <<
char buf[1024];
strcpy(buf, filename);
FILE* fp = fopen(strcat(buf,".xml"), "w");
fwrite(bitStrm.buf, 1, bitStrm.currentByte, fp);
fclose(fp);
>>

Codec_write_bitstreamToFile() ::= <<
char buf[1024];
strcpy(buf, filename);
FILE* fp = fopen(strcat(buf,".dat"), "wb");
fwrite(bitStrm.buf, 1, bitStrm.currentBit > 0 ? bitStrm.currentByte + 1 : bitStrm.currentByte, fp);
fclose(fp);
>>

JoinItems(sPart, soNestedPart) ::= <<
<sPart>
<if(soNestedPart)>
if (ret) {
    <soNestedPart>
}

<endif>
>>


Codec_declare_EncInDecOut_variable(sPrmName, sType, sPrmValue) ::= <<
<sType> enc_<sPrmName> = <sPrmValue>;
<sType> dec_<sPrmName>;
>>

Codec_declare_DecIn_variable(sPrmName, sType) ::= "<sType> dec_<sPrmName>;"


PrintCodec_spec(sFuncName, sModName, sTasName, sStar, sVal) ::= <<
flag <sFuncName>(const <sTasName><sStar> <sVal>, int* pErrCode, const char* filename);
>>

PrintCodec_body(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements, sCodecClass) ::= <<
flag <sFuncName>(const <sTasName><sStar> <sVal>, int* pErrCode, const char* filename)
{
    static <sTasName> decodedPDU;
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; /* +1 for zerosized types */
    BitStream bitStrm;
    flag ret = TRUE;

    BitStream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    <sNestedStatements>
    return ret;
}
>>

PrintCodec_body_XER(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
flag <sFuncName>(const <sTasName><sStar> <sVal>, int* pErrCode, const char* filename)
{
    static <sTasName> decodedPDU;
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; /* +1 for zerosized types */
    ByteStream bitStrm;
    flag ret = TRUE;

    ByteStream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    <sNestedStatements>
    return ret;
}
>>






/* Encode Decode End*/


PrintMain(sTestSuiteFilename) ::= <<
#include \<stdio.h>

#include "<sTestSuiteFilename>.h"

static void printf_tests_failed(int testCount, int failedCount)
{
    printf("%d out of %d failed.\n", failedCount, testCount);
}

static void printf_tests_passed(int testCount)
{
    printf("All test cases (%d) run successfully.\n", testCount);
}

static void printf_null()
{
}

static void printf_null_char(const char* s)
{
    (void)s;
}

static void printf_message(const char* message)
{
    printf("%s\n", message);
}

static void print_test_case_success(const char* message, const long duration) {
    printf("test case '%s' succeeded, duration was \t\t\t\t%lu ms\n", message, duration);
}

int main(int argc, char* argv[])
{
    (void)argc;
    (void)argv;

    TestOutput output = {
               .report_tests_failed = printf_tests_failed,
               .report_all_tests_passed = printf_tests_passed,
               .report_suite_begin = printf_null,
               .report_suite_end = printf_null,
               .report_case_begin = printf_null_char,
               .report_case_end = printf_null,
               .report_failure_begin = printf_null,
               .report_failure_end = printf_null,
               .report_failure_message = printf_message,
               .report_test_case_success = print_test_case_success
    };

    return asn1scc_run_generated_testsuite(&output);
}

>>





PrintSuite_call_codec_generate_dat_file(sModName, sTasName, sAmber, sEnc, sStreamName) ::= <<
	if (result) {
		static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; /* +1 for zerosized types */
		<sStreamName>Stream bitStrm;
		FILE* fp;

  		<sStreamName>Stream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);

		result = <sTasName>_<sEnc>Encode(<sAmber>tmp, &bitStrm, &errCode, TRUE);
		fp = fopen("asn1scc_<sEnc>.dat","wb");

		if (fp==NULL)
		{
			printf("fopen failed !!!\n");
			return 2;
		}


		fwrite(encBuff,1,(size_t)<sStreamName>Stream_GetLength(&bitStrm),fp);
		fclose(fp);
	};
>>


PrintATCRunnerDefinition() ::= <<
#ifndef GENERATED_ASN1SCC_TESTSUITE_H
#define GENERATED_ASN1SCC_TESTSUITE_H

#ifdef  __cplusplus
extern "C" {
#endif

typedef struct {
    void (*report_tests_failed)(int testsCount, int failedCount);
    void (*report_all_tests_passed)(int testsCount);

    void (*report_suite_begin)();
    void (*report_suite_end)();

    void (*report_case_begin)(const char* caseName);
    void (*report_case_end)();

    void (*report_failure_begin)();
    void (*report_failure_end)();
    void (*report_failure_message)(const char* message);
    void (*report_test_case_success)(const char* message, const long duration);
} TestOutput;

int asn1scc_run_generated_testsuite(TestOutput* output);

#ifdef  __cplusplus
}
#endif


#endif // GENERATED_ASN1SCC_TESTSUITE_H

>>

PrintATCRunner(sTestSuiteFilename, arrsIncludedModules, arrsVars, arrsTestFunctions, arrsUsedPackages, arrsInitCalls, bGenerateDatFile) ::= <<
/*  Code automatically generated by asn1scc tool (stg macro : PrintATCRunner) */

#include "<sTestSuiteFilename>.h"

#include \<stdio.h>
#include \<string.h>
#include \<math.h>
#include \<float.h>
#include \<limits.h>

#include "asn1crt.h"

<arrsIncludedModules:{inc| #include "<inc>.h"}; separator="\n">

int asn1scc_run_generated_testsuite(TestOutput* output)
{
    int totalErrors = 0;
    <arrsVars; separator="\n">


    output->report_suite_begin();

    <arrsTestFunctions;separator="\n\n">

    output->report_suite_end();

    if (totalErrors > 0 ) {
        output->report_tests_failed(<arrsTestFunctions.Length>, totalErrors);
        return 1;
    } else {
        output->report_all_tests_passed(<arrsTestFunctions.Length>);
        return 0;
    }
}

>>



invokeTestCaseAsFunc(sFuncName) ::= <<
<sFuncName>(output, &totalErrors);
>>


emitTestCaseAsFunc_h(sFuncName) ::= <<
void <sFuncName>(const TestOutput* output, int *totalErrors);
>>

emitTestCaseAsFunc_dummy_init(sTypeName, sFuncName, sDummyVarname) ::= <<
<sFuncName>(<sDummyVarname>);
>>

emitTestCaseAsFunc_dummy_init_function(sTypeName, sFuncName, sDummyVarname) ::= <<
//This macro should never be called for C. C does not support init functions, only init procedures
//<sDummyVarname> = <sFuncName>();
>>

emitTestCaseAsFunc(sFuncName, arrsVars, sModName, sTasName, sAmber, sEnc, bValueAssignment, sInitializeTcData, bStatic, sGenerateDatFile, arrsDummyInitStatementsNeededForStatementCoverage, sInitAmber) ::= <<
void <sFuncName>(const TestOutput* output, int *totalErrors)
{
    flag result;
    int errCode;
    <arrsVars; separator="\n">

    output->report_case_begin("<sFuncName>");
    <if(arrsDummyInitStatementsNeededForStatementCoverage)>
    {
        // dummy statement used for calling init functions
        <if(bStatic)>        static <endif><sTasName> tmp0;
        <arrsDummyInitStatementsNeededForStatementCoverage; separator="\n">
    }

    <endif>
    <if(bStatic)>    static <endif><sTasName> tc_data<if(bValueAssignment)> = <else>; <endif>
    <sInitializeTcData><if(bValueAssignment)>;<endif>
#ifndef _MSC_VER
    struct timeval stop, start;
    gettimeofday(&start, NULL);
    result = <sTasName>_<sEnc>enc_dec(<sAmber>tc_data, &errCode, "<sFuncName>");
    gettimeofday(&stop, NULL);
    if (result) {
        output->report_test_case_success("<sTasName>/<sFuncName>", ((stop.tv_sec - start.tv_sec) * 1000000 + stop.tv_usec - start.tv_usec)/1000);
    } else {
#else
    result = <sTasName>_<sEnc>enc_dec(<sAmber>tc_data, &errCode, "<sFuncName>");
    if (!result) {
#endif

        output->report_failure_begin();

        switch(errCode)
        {
        case 1:
            output->report_failure_message("Test case <sFuncName> failed in encoding.");
            break;
        case 2:
            output->report_failure_message("Test case '<sFuncName>' failed in decoding.");
            break;
        case 3:
            output->report_failure_message("Test case '<sFuncName>' failed in the validation of the decoded message.");
            break;
        case 4:
            output->report_failure_message("Test case '<sFuncName>' failed. Encoded and decoded messages are different.");
            break;
        default:
            output->report_failure_message("Unexpected error code in test case '<sFuncName>'.");
        }
        output->report_failure_message("========================================");
        *totalErrors = (*totalErrors) + 1;

        output->report_failure_end();
    }
    <sGenerateDatFile>

    output->report_case_end();
}
>>


printTestCaseFileDef(sThisFile, arrsIncludedModules, arrsTestFunctionDefs) ::= <<

#ifndef GENERATED_ASN1SCC_<sThisFile>_H
#define GENERATED_ASN1SCC_<sThisFile>_H
/*
Code automatically generated by asn1scc tool
*/
#include "asn1crt.h"
#include "testsuite.h"
<arrsIncludedModules:{inc| #include "<inc>"}; separator="\n">

#ifdef  __cplusplus
extern "C" {
#endif
<arrsTestFunctionDefs;separator="\n\n">

#ifdef  __cplusplus
}

#endif

#endif

>>


printTestCaseFileBody(sThisFile, arrsIncludedModules, arrsTestFunctionBodies) ::= <<
/*  Code automatically generated by asn1scc tool (stg macro : printTestCaseFileBody) */

#include "<sThisFile>.h"

#include \<stdio.h>
#include \<string.h>
#include \<math.h>
#include \<float.h>
#include \<limits.h>

#ifndef _MSC_VER
#include \<sys/time.h\>

#endif // _MSC_VER

#include "asn1crt.h"

<arrsIncludedModules:{inc| #include "<inc>"}; separator="\n">

<arrsTestFunctionBodies;separator="\n\n">

>>

decodingCaseKind(sBody, sIdentifier) ::= <<
<sBody>
>>
