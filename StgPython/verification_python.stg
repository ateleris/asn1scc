group verification_python;

/*
*****************************************************************************************
 S E G M E N T S   V A L I D   F U N C T I O N S
*****************************************************************************************
*/

segments_valid_sequence(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_valid(segments: PSeq[Segment]) -> SegmentsValid:
    is_valid = True
    <arrsChildren:{child|<child>}; separator="\n">
    return SegmentsValid(is_valid, segments)
>>

segments_valid_child_mandatory(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Check segments for <sChildName>
<if(bIsPrimitive)>
is_valid = is_valid and segments[0].length == <bitSize>
segments = segments_drop(segments, 1)
<else>
child_<sChildName> = <sChildType>.segments_valid(segments)
is_valid, segments = is_valid and child_<sChildName>.valid, child_<sChildName>.segments
<endif>
>>

segments_valid_child_optional(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Check segments for optional <sChildName>
if val.<sChildName> is not None:
    <segments_valid_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_valid_child_sequenceof(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Check segments for sequence-of <sChildName>
# TODO refactor loop
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <segments_valid_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_valid_child_choice(sChildName, sChildType) ::= <<
# Check segments for choice <sChildName>
child_<sChildName> = <sChildType>.segments_valid(segments)
is_valid, segments = is_valid and child_<sChildName>.valid, child.segments
>>

segments_valid_primitive(sTypeName, bitSize) ::= <<
@Pure
@staticmethod
def segments_valid(segments: PSeq[Segment]) -> SegmentsValid:
    return SegmentsValid(segments[0].length == <bitSize>, segments_drop(segments, 1))
>>

/*
*****************************************************************************************
 S E G M E N T S   O F   F U N C T I O N S
*****************************************************************************************
*/

segments_of_sequence(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Ensures(<sTypeName>.segments_valid(Result()).valid)
    segments: PSeq[Segment] = PSeq()
    <arrsChildren:{child|<child>}; separator="\n">
    return segments
>>

segments_of_child_mandatory(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Collect segments from <sChildName>
<if(bIsPrimitive)>
segments = segments + PSeq(Segment(<bitSize>, val.<sChildName>))
<else>
segments = segments + <sChildType>.segments_of(val.<sChildName>)
<endif>
>>

segments_of_child_optional(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Collect segments from optional <sChildName>
if val.<sChildName> is not None:
    <segments_of_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_of_child_sequenceof(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Collect segments from sequence-of <sChildName>
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <segments_of_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_of_child_choice(sChildName, sChildType) ::= <<
# Collect segments from choice <sChildName>
segments = segments + <sChildType>.segments_of(val.<sChildName>)
>>

segments_of_primitive(sTypeName, bitSize) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Ensures(<sTypeName>.segments_valid(Result()).valid)
    segments: PSeq[Segment] = PSeq(Segment(<bitSize>, val))
    return segments
>>

segments_of_boolean(sTypeName, bitSize) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Ensures(<sTypeName>.segments_valid(Result()).valid)
    segments: PSeq[Segment] = PSeq(Segment(<bitSize>, val.value))
    return segments
>>

segments_of_nulltype(sTypeName, bitSize) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Ensures(<sTypeName>.segments_valid(Result()).valid)
    segments: PSeq[Segment] = PSeq(Segment(<bitSize>, 0))
    return segments
>>

/*
*****************************************************************************************
 S E G M E N T S    C O U N T    F U N C T I O N S
*****************************************************************************************
*/

segments_count_sequence(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_count(segments: PSeq[Segment]) -> int:
    Requires(<sTypeName>.segments_valid(segments).valid)
    count = 0
    <arrsChildren:{child|<child>}; separator="\n">
    return count
>>

segments_count_child_mandatory(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Segments count for <sChildName>
<if(bIsPrimitive)>
count = count + 1, segments_drop(segments, 1)
<else>
count_<sChildName> = <sChildType>.segments_count(segments)
count, segments = count + count_<sChildName>, segments_drop(segments, count_<sChildName>)
<endif>
>>

segments_count_child_optional(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Segments count for optional <sChildName>
if val.<sChildName> is not None:
    <segments_count_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_count_child_sequenceof(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Segments count for sequence-of <sChildName>
# TODO refactor loop
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <segments_count_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_count_child_choice(sChildName, sChildType) ::= <<
# Segments count for choice <sChildName>
count_<sChildName> = <sChildType>.segments_count(segments)
count, segments = count + count_<sChildName>, segments_drop(segments, count_<sChildName>)
>>

segments_count_primitive(sTypeName, bitSize) ::= <<
@Pure
@staticmethod
def segments_count(segments: PSeq[Segment]) -> int:
    Requires(<sTypeName>.segments_valid(segments).valid)
    return 1
>>

/*
*****************************************************************************************
 S E G M E N T S    E Q    L E M M A    F U N C T I O N S
*****************************************************************************************
*/

segments_eq_lemma_sequence(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_eq_lemma(left: '<sTypeName>', right: '<sTypeName>') -> bool:
    Requires(<sTypeName>.segments_of(left) == <sTypeName>.segments_of(right))
    Ensures(left == right)

    segments_left = <sTypeName>.segments_of(left)
    segments_right = <sTypeName>.segments_of(right)
    <arrsChildren:{child|<child>}; separator="\n">
    return True
>>

segments_eq_lemma_child_mandatory(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Segments Eq Lemma for <sChildName>
<if(bIsPrimitive)>
Assert(segments_left[0] == segments_right[0])
segments_left = segments_drop(segments_left, 1)
segments_right = segments_drop(segments_right, 1)
<else>
Assert(<sChildType>.segments_eq_lemma(left.<sChildName>, right.<sChildName>))
<endif>
>>

segments_eq_lemma_child_optional(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Segments Eq Lemma for optional <sChildName>
if val.<sChildName> is not None:
    <segments_eq_lemma_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_eq_lemma_child_sequenceof(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Segments Eq Lemma for sequence-of <sChildName>
# TODO refactor loop
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <segments_eq_lemma_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_eq_lemma_child_choice(sChildName, sChildType) ::= <<
# Segments Eq Lemma for choice <sChildName>
Assert(segments_left[0] == segments_right[0])
segments_left = segments_drop(segments_left, 1)
segments_right = segments_drop(segments_right, 1)
>>

segments_eq_lemma_primitive(sTypeName, bitSize) ::= <<
@Pure
@staticmethod
def segments_eq_lemma(left: '<sTypeName>', right: '<sTypeName>') -> bool:
    Requires(<sTypeName>.segments_of(left) == <sTypeName>.segments_of(right))
    Ensures(left == right)
    return True
>>