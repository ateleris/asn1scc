group verification_python;

/*
*****************************************************************************************
 S E G M E N T S   V A L I D   F U N C T I O N S
*****************************************************************************************
*/

segments_valid_sequence(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_valid(segments: PSeq[Segment]) -> Tuple[bool, PSeq[Segment]]:
    is_valid = True
    <arrsChildren:{child|<child>}; separator="\n">
    return is_valid, segments
>>

segments_valid_child_mandatory(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Check segments for <sChildName>
<if(bIsPrimitive)>
is_valid = is_valid and segments[0].length == <bitSize>
segments = segments.drop(1)
<else>
is_valid, segments = is_valid and <sChildType>.segments_valid(segments)
<endif>
>>

segments_valid_child_optional(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Check segments for optional <sChildName>
if val.<sChildName> is not None:
    <segments_valid_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_valid_child_sequenceof(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Check segments for sequence-of <sChildName>
# TODO refactor loop
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <segments_valid_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_valid_child_choice(sChildName, sChildType) ::= <<
# Check segments for choice <sChildName>
is_valid, segments = is_valid and <sChildType>.segments_valid(segments)
>>

segments_valid_boolean(sTypeName) ::= <<
@Pure
@staticmethod
def segments_valid(segments: PSeq[Segment]) -> Tuple[bool, PSeq[Segment]]:
    return segments[0].length == <sTypeName>.EncodeConstants.<sTypeName>_REQUIRED_BITS_FOR_ENCODING, segments.drop(1)
>>

segments_valid_integer(sTypeName) ::= <<
@Pure
@staticmethod
def segments_valid(segments: PSeq[Segment]) -> Tuple[bool, PSeq[Segment]]:
    return segments[0].length == <sTypeName>.EncodeConstants.<sTypeName>_REQUIRED_BITS_FOR_ENCODING, segments.drop(1)
>>

segments_valid_nulltype(sTypeName) ::= <<
@Pure
@staticmethod
def segments_valid(segments: PSeq[Segment]) -> Tuple[bool, PSeq[Segment]]:
    return segments[0].length == <sTypeName>.EncodeConstants.<sTypeName>_REQUIRED_BITS_FOR_ENCODING, segments.drop(1)
>>

/*
*****************************************************************************************
 S E G M E N T S   O F   F U N C T I O N S
*****************************************************************************************
*/

segments_of_sequence(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Ensures(<sTypeName>.segments_valid(Result()))
    segments: PSeq[Segment] = PSeq()
    <arrsChildren:{child|<child>}; separator="\n">
    return segments
>>

segments_of_child_mandatory(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Collect segments from <sChildName>
<if(bIsPrimitive)>
segments = segments + PSeq(Segment(<bitSize>, val.<sChildName>))
<else>
segments = segments + <sChildType>.segments_of(val.<sChildName>)
<endif>
>>

segments_of_child_optional(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Collect segments from optional <sChildName>
if val.<sChildName> is not None:
    <segments_of_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_of_child_sequenceof(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Collect segments from sequence-of <sChildName>
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <segments_of_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_of_child_choice(sChildName, sChildType) ::= <<
# Collect segments from choice <sChildName>
segments = segments + <sChildType>.segments_of(val.<sChildName>)
>>

segments_of_boolean(sTypeName) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Ensures(<sTypeName>.segments_valid(Result()))
    segments: PSeq[Segment] = PSeq(Segment(val.EncodeConstants.<sTypeName>_REQUIRED_BITS_FOR_ENCODING , val))
    return segments
>>

segments_of_integer(sTypeName) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Ensures(<sTypeName>.segments_valid(Result()))
    segments: PSeq[Segment] = PSeq(Segment(val.EncodeConstants.<sTypeName>_REQUIRED_BITS_FOR_ENCODING , val))
    return segments
>>

segments_of_nulltype(sTypeName) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Ensures(<sTypeName>.segments_valid(Result()))
    segments: PSeq[Segment] = PSeq(Segment(val.EncodeConstants.<sTypeName>_REQUIRED_BITS_FOR_ENCODING , 0))
    return segments
>>

/*
*****************************************************************************************
 S E G M E N T S    C O U N T    F U N C T I O N S
*****************************************************************************************
*/

segments_count_sequence(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_count(segments: PSeq[Segment]) -> Tuple[int, PSeq[Segment]]:
    Requires(<sTypeName>.segments_valid(segments))
    count = 0
    <arrsChildren:{child|<child>}; separator="\n">
    return count, segments
>>

segments_count_child_mandatory(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Segments count for <sChildName>
<if(bIsPrimitive)>
count += 1
segments = segments.drop(1)
<else>
count_inner, segments = <sChildType>.segments_count(segments)
count += count_inner
<endif>
>>

segments_count_child_optional(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Segments count for optional <sChildName>
if val.<sChildName> is not None:
    <segments_count_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_count_child_sequenceof(sChildName, sChildType, bIsPrimitive, bitSize) ::= <<
# Segments count for sequence-of <sChildName>
# TODO refactor loop
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <segments_count_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, bitSize=bitSize)>
>>

segments_count_child_choice(sChildName, sChildType) ::= <<
# Segments count for choice <sChildName>
count_inner, segments = <sChildType>.segments_count(segments)
count += count_inner
>>

segments_count_boolean(sTypeName) ::= <<
@Pure
@staticmethod
def segments_count(segments: PSeq[Segment]) -> Tuple[int, PSeq[Segment]]:
    Requires(<sTypeName>.segments_valid(segments))
    return 1, segments.drop(1)
>>

segments_count_integer(sTypeName) ::= <<
@Pure
@staticmethod
def segments_count(segments: PSeq[Segment]) -> Tuple[int, PSeq[Segment]]:
    Requires(<sTypeName>.segments_valid(segments))
    return 1, segments.drop(1)
>>

segments_count_nulltype(sTypeName) ::= <<
@Pure
@staticmethod
def segments_count(segments: PSeq[Segment]) -> Tuple[int, PSeq[Segment]]:
    Requires(<sTypeName>.segments_valid(segments))
    return 1, segments.drop(1)
>>