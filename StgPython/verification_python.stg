group verification_python;

segments_of_sequence(sTypeName, arrsChildren) ::= <<
@staticmethod
@Pure
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    segments: PSeq[Segment] = PSeq()
    <arrsChildren:{child|<child>}; separator="\n">
    return segments
>>

segments_of_child_mandatory(sChildName, sChildType, bIsPrimitive) ::= <<
# Collect segments from <sChildName>
<if(bIsPrimitive)>
# Primitive type - single segment
segments = segments + PSeq(Segment(<sChildType>.size_in_bits(), val.<sChildName>))
<else>
segments = segments + <sChildType>.segments_of(val.<sChildName>)
<endif>
>>

segments_of_child_optional(sChildName, sChildType, bIsPrimitive) ::= <<
# Collect segments from optional <sChildName>
if val.<sChildName> is not None:
    <if(bIsPrimitive)>
    # Primitive type - single segment
    segments = segments + PSeq(Segment(<sChildType>.size_in_bits(), val.<sChildName>))
    <else>
    segments = segments + <sChildType>.segments_of(val.<sChildName>)
    <endif>
>>

segments_of_child_sequenceof(sChildName, sChildType, bIsPrimitive) ::= <<
# Collect segments from sequence-of <sChildName>
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <if(bIsPrimitive)>
    segments = segments + PSeq(Segment(<sChildType>.size_in_bits(), item))
    <else>
    segments = segments + <sChildType>.segments_of(item)
    <endif>
>>

segments_of_child_choice(sChildName, sChildType) ::= <<
# Collect segments from choice <sChildName>
segments = segments + <sChildType>.segments_of(val.<sChildName>)
>>

segments_of_boolean(sTypeName) ::= <<
@staticmethod
@Pure
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    segments: PSeq[Segment] = PSeq(Segment(val.EncodeConstants.<sTypeName>_REQUIRED_BITS_FOR_ENCODING , val))
    return segments
>>
