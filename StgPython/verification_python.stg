group verification_python;

/*
*****************************************************************************************
 C L A S S   P R E D I C A T E
*****************************************************************************************
*/

list_perm_access(sFieldName) ::= <<list_pred(self.<sFieldName>)>>

class_predicate_fields(arrsFieldAccess) ::= <<
@Predicate
def class_predicate(self) -> bool:
    <if(arrsFieldAccess)>
    return <arrsFieldAccess:{acc|Acc(<acc>)}; separator=" and ">
    <else>
    return True
    <endif>
>>

/*
*****************************************************************************************
 S E G M E N T S   V A L I D   F U N C T I O N S
*****************************************************************************************
*/

segments_valid_sequence(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_valid(segments: PSeq[Segment]) -> bool:
    Requires(Forall(segments, lambda seg: segment_invariant(seg)))
    is_valid = True
    <arrsChildren:{child|<child>}; separator="\n">
    return is_valid
>>

segments_valid_child_mandatory(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Check segments for <sChildName>
<if(bIsPrimitive)>
is_valid = is_valid and len(segments) > 0 and segments[0].length == <nBitSize>
segments = segments_drop(segments, 1)
<else>
is_valid = is_valid and <sChildType>.segments_valid(segments)
segments = segments_drop(segments, <sChildType>.segments_count(segments))
<endif>
>>

segments_valid_child_optional(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Check segments for optional <sChildName>
if val.<sChildName> is not None:
    <segments_valid_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, nBitSize=nBitSize)>
>>

segments_valid_child_sequenceof(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Check segments for sequence-of <sChildName>
# TODO refactor loop
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <segments_valid_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, nBitSize=nBitSize)>
>>

segments_valid_child_choice(sChildName, sChildType) ::= <<
# Check segments for choice <sChildName>
is_valid = is_valid and <sChildType>.segments_valid(segments)
segments = segments_drop(segments, <sChildType>.segments_count(segments))
>>

segments_valid_choice_child(nIndex, sChildType, bIsPrimitive, nDataBitSize, nTagBitSize) ::= <<
(len(segments) >= 1 and segments[0].length == <nTagBitSize> and segments[0].value == <nIndex> and <if(bIsPrimitive)>len(segments) >= 2 and segments[1].length == <nDataBitSize><else><sChildType>.segments_valid(segments_drop(segments, 1))<endif>)>>

segments_valid_choice(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_valid(segments: PSeq[Segment]) -> bool:
    Requires(Forall(segments, lambda seg: segment_invariant(seg)))
    return (<arrsChildren:{child|<child>}; separator=" or\n           ">)
>>

segments_valid_sequenceOf(sTypeName, sSegCount, nBitSize) ::= <<
@Pure
@staticmethod
def segments_valid(segments: PSeq[Segment]) -> bool:
    Requires(Forall(segments, lambda seg: segment_invariant(seg)))
    return len(segments) \>= <sSegCount> and Forall(segments_take(segments, <sSegCount>), lambda seg: seg.length == <nBitSize>)
>>

segments_valid_primitive(sTypeName, nBitSize) ::= <<
@Pure
@staticmethod
def segments_valid(segments: PSeq[Segment]) -> bool:
    Requires(Forall(segments, lambda seg: segment_invariant(seg)))
    return len(segments) > 0 and segments[0].length == <nBitSize>
>>

segments_valid_octetString(sTypeName, sSegCount) ::= <<
@Pure
@staticmethod
def segments_valid(segments: PSeq[Segment]) -> bool:
    Requires(Forall(segments, lambda seg: segment_invariant(seg)))
    return len(segments) \>= <sSegCount> and Forall(segments_take(segments, <sSegCount>), lambda seg: seg.length == 8)
>>


/*
*****************************************************************************************
 S E G M E N T S   O F   F U N C T I O N S
*****************************************************************************************
*/

segments_of_sequence(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Requires(Rd(val.class_predicate()) and val.is_constraint_valid_pure())
    Ensures(Forall(ResultT(PSeq[Segment]), lambda seg: segment_invariant(seg)))
    Ensures(<sTypeName>.segments_valid(ResultT(PSeq[Segment])))
    Unfold(Rd(val.class_predicate()))
    segments: PSeq[Segment] = PSeq()
    <arrsChildren:{child|<child>}; separator="\n">
    return segments
>>

segments_of_child_mandatory(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Collect segments from <sChildName>
<if(bIsPrimitive)>
segments = segments + PSeq(Segment(<nBitSize>, val.<sChildName>))
<else>
segments = segments + <sChildType>.segments_of(val.<sChildName>)
<endif>
>>

segments_of_child_optional(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Collect segments from optional <sChildName>
if val.<sChildName> is not None:
    <segments_of_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, nBitSize=nBitSize)>
>>

segments_of_child_sequenceof(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Collect segments from sequence-of <sChildName>
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <segments_of_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, nBitSize=nBitSize)>
>>

segments_of_child_choice(sChildName, sChildType) ::= <<
# Collect segments from choice <sChildName>
segments = segments + <sChildType>.segments_of(val.<sChildName>)
>>

segments_of_choice_child(sPresentWhenName, nIndex, sChildType, bIsPrimitive, nDataBitSize, nTagBitSize) ::= <<
if val.kind == <sPresentWhenName>:
    <if(bIsPrimitive)>
    segments = PSeq(Segment(<nTagBitSize>, <nIndex>)) + PSeq(Segment(<nDataBitSize>, val.data))
    <else>
    segments = PSeq(Segment(<nTagBitSize>, <nIndex>)) + <sChildType>.segments_of(val.data)
    <endif>
>>

segments_of_choice(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Requires(Rd(val.class_predicate()) and val.is_constraint_valid_pure())
    Ensures(Forall(ResultT(PSeq[Segment]), lambda seg: segment_invariant(seg)))
    Ensures(<sTypeName>.segments_valid(ResultT(PSeq[Segment])))
    Unfold(Rd(val.class_predicate()))
    segments: PSeq[Segment] = PSeq()
    <arrsChildren:{child|<child>}; separator="\nel">
    return segments
>>

segments_of_sequenceOf(sTypeName, sArrName) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Requires(Rd(val.class_predicate()) and val.is_constraint_valid_pure())
    Ensures(Forall(ResultT(PSeq[Segment]), lambda seg: segment_invariant(seg)))
    Ensures(<sTypeName>.segments_valid(ResultT(PSeq[Segment])))
    ## TODO
    return segments   
>>

segments_of_primitive(sTypeName, nBitSize) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Requires(val.is_constraint_valid_pure())
    Ensures(Forall(ResultT(PSeq[Segment]), lambda seg: segment_invariant(seg)))
    Ensures(<sTypeName>.segments_valid(ResultT(PSeq[Segment])))
    segments: PSeq[Segment] = PSeq(Segment(<nBitSize>, val))
    return segments
>>

segments_of_boolean(sTypeName, nBitSize) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Requires(val.is_constraint_valid_pure())
    Ensures(Forall(ResultT(PSeq[Segment]), lambda seg: segment_invariant(seg)))
    Ensures(<sTypeName>.segments_valid(ResultT(PSeq[Segment])))
    segments: PSeq[Segment] = PSeq(Segment(<nBitSize>, val.value))
    return segments
>>

segments_of_nulltype(sTypeName, nBitSize) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Requires(val.is_constraint_valid_pure())
    Ensures(Forall(ResultT(PSeq[Segment]), lambda seg: segment_invariant(seg)))
    Ensures(<sTypeName>.segments_valid(ResultT(PSeq[Segment])))
    segments: PSeq[Segment] = PSeq(Segment(<nBitSize>, 0))
    return segments
>>

segments_of_enum(sTypeName, nBitSize) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Requires(val.is_constraint_valid_pure())
    Ensures(Forall(ResultT(PSeq[Segment]), lambda seg: segment_invariant(seg)))
    Ensures(<sTypeName>.segments_valid(ResultT(PSeq[Segment])))
    segments: PSeq[Segment] = PSeq(Segment(<nBitSize>, int(val.val)))
    return segments
>>

segments_of_octetString(sTypeName, sArrName) ::= <<
@Pure
@staticmethod
def segments_of(val: '<sTypeName>') -> PSeq[Segment]:
    Requires(Rd(val.class_predicate()) and val.is_constraint_valid_pure())
    Ensures(Forall(ResultT(PSeq[Segment]), lambda seg: segment_invariant(seg)))
    Ensures(<sTypeName>.segments_valid(ResultT(PSeq[Segment])))
    Unfold(Rd(val.class_predicate()))
    byteseq = ToByteSeq(val.<sArrName>)
    segments = segments_from_byteseq_full(byteseq)
    return segments    
>>

/*
*****************************************************************************************
 S E G M E N T S    C O U N T    F U N C T I O N S
*****************************************************************************************
*/

segments_count_sequence(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_count(segments: PSeq[Segment]) -> int:
    Requires(Forall(segments, lambda seg: segment_invariant(seg)))
    Requires(<sTypeName>.segments_valid(segments))
    count = 0
    <arrsChildren:{child|<child>}; separator="\n">
    return count
>>

segments_count_child_mandatory(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Segments count for <sChildName>
<if(bIsPrimitive)>
count = count + 1
segments = segments_drop(segments, 1)
<else>
count_<sChildName> = <sChildType>.segments_count(segments)
count = count + count_<sChildName>
segments = segments_drop(segments, count_<sChildName>)
<endif>
>>

segments_count_child_optional(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Segments count for optional <sChildName>
if val.<sChildName> is not None:
    <segments_count_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, nBitSize=nBitSize)>
>>

segments_count_child_sequenceof(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Segments count for sequence-of <sChildName>
# TODO refactor loop
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <segments_count_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, nBitSize=nBitSize)>
>>

segments_count_child_choice(sChildName, sChildType) ::= <<
# Segments count for choice <sChildName>
count_<sChildName> = <sChildType>.segments_count(segments)
count = count + count_<sChildName>
segments = segments_drop(segments, count_<sChildName>)
>>

segments_count_choice_child(nIndex, sChildType, bIsPrimitive) ::= <<
if segments[0].value == <nIndex>:
    <if(bIsPrimitive)>
    count = 2
    <else>
    segments = segments_drop(segments, 1)
    count = 1 + <sChildType>.segments_count(segments)
    <endif>
>>

segments_count_choice(sTypeName, arrsChildren) ::= <<
@Pure
@staticmethod
def segments_count(segments: PSeq[Segment]) -> int:
    Requires(Forall(segments, lambda seg: segment_invariant(seg)))
    Requires(<sTypeName>.segments_valid(segments))
    count = 0
    <arrsChildren:{child|<child>}; separator="\nel">
    return count
>>

segments_count_primitive(sTypeName, sSegCount) ::= <<
@Pure
@staticmethod
def segments_count(segments: PSeq[Segment]) -> int:
    Requires(Forall(segments, lambda seg: segment_invariant(seg)))
    Requires(<sTypeName>.segments_valid(segments))
    return <sSegCount>
>>

segments_count_var_size(sTypeName) ::= <<
@Pure
@staticmethod
def segments_count(segments: PSeq[Segment]) -> int:
    Requires(Forall(segments, lambda seg: segment_invariant(seg)))
    Requires(<sTypeName>.segments_valid(segments))
    return 1 + segments[0].value
>>


/*
*****************************************************************************************
 S E G M E N T S    E Q    L E M M A    F U N C T I O N S
*****************************************************************************************
*/

segments_eq_lemma_sequence(sTypeName, arrsChildren) ::= <<
@Pure
@Opaque
@staticmethod
def segments_eq_lemma(left: '<sTypeName>', right: '<sTypeName>') -> bool:
    Requires(Rd(left.class_predicate()) and left.is_constraint_valid_pure())
    Requires(Rd(right.class_predicate()) and right.is_constraint_valid_pure())
    Requires(<sTypeName>.segments_of(left) == <sTypeName>.segments_of(right))
    Ensures(left == right)
    Ensures(Result())

    Unfold(Rd(left.class_predicate()))
    Unfold(Rd(right.class_predicate()))
    
    segments_left = <sTypeName>.segments_of(left)
    segments_right = <sTypeName>.segments_of(right)
    <arrsChildren:{child|<child>}; separator="\n">
    return True
>>

segments_eq_lemma_child_mandatory(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Segments Eq Lemma for <sChildName>
<if(bIsPrimitive)>
Assert(segments_left[0] == segments_right[0])
segments_left = segments_drop(segments_left, 1)
segments_right = segments_drop(segments_right, 1)
<else>
Assert(<sChildType>.segments_eq_lemma(left.<sChildName>, right.<sChildName>))
<endif>
>>

segments_eq_lemma_child_optional(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Segments Eq Lemma for optional <sChildName>
if val.<sChildName> is not None:
    <segments_eq_lemma_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, nBitSize=nBitSize)>
>>

segments_eq_lemma_child_sequenceof(sChildName, sChildType, bIsPrimitive, nBitSize) ::= <<
# Segments Eq Lemma for sequence-of <sChildName>
# TODO refactor loop
for item in val.<sChildName>.arr[:val.<sChildName>.nCount]:
    <segments_eq_lemma_child_mandatory(sChildName=sChildName, sChildType=sChildType, bIsPrimitive=bIsPrimitive, nBitSize=nBitSize)>
>>

segments_eq_lemma_child_choice(sChildName, sChildType) ::= <<
# Segments Eq Lemma for choice <sChildName>
Assert(<sChildType>.segments_eq_lemma(left.<sChildName>, right.<sChildName>))
>>

segments_eq_lemma_choice_child(sPresentWhenName, sChildType, bIsPrimitive) ::= <<
if left.kind == <sPresentWhenName>:
    <if(bIsPrimitive)>
    Assert(segments_left[1] == segments_right[1])
    <else>
    Assert(<sChildType>.segments_eq_lemma(left.data, right.data))
    <endif>
>>

segments_eq_lemma_choice(sTypeName, arrsChildren) ::= <<
@Pure
@Opaque
@staticmethod
def segments_eq_lemma(left: '<sTypeName>', right: '<sTypeName>') -> bool:
    Requires(Rd(left.class_predicate()) and left.is_constraint_valid_pure())
    Requires(Rd(right.class_predicate()) and right.is_constraint_valid_pure())
    Requires(<sTypeName>.segments_of(left) == <sTypeName>.segments_of(right))
    Ensures(left == right)
    Ensures(Result())

    Unfold(Rd(left.class_predicate()))
    Unfold(Rd(right.class_predicate()))

    segments_left = <sTypeName>.segments_of(left)
    segments_right = <sTypeName>.segments_of(right)
    <arrsChildren:{child|<child>}; separator="\nel">
    return True
>>


segments_eq_lemma_sequenceOf(sTypeName, sArrName) ::= <<
@Pure
@Opaque
@staticmethod
def segments_eq_lemma(left: '<sTypeName>', right: '<sTypeName>') -> bool:
    Requires(Rd(left.class_predicate()) and left.is_constraint_valid_pure())
    Requires(Rd(right.class_predicate()) and right.is_constraint_valid_pure())
    Requires(<sTypeName>.segments_of(left) == <sTypeName>.segments_of(right))
    Ensures(left == right)
    Ensures(Result())

    Unfold(Rd(left.class_predicate()))
    Unfold(Rd(right.class_predicate()))

    ## TODO
    return True
>>

segments_eq_lemma_primitive(sTypeName, nBitSize) ::= <<
@Pure
@Opaque
@staticmethod
def segments_eq_lemma(left: '<sTypeName>', right: '<sTypeName>') -> bool:
    Requires(left.is_constraint_valid_pure() and right.is_constraint_valid_pure())
    Requires(<sTypeName>.segments_of(left) == <sTypeName>.segments_of(right))
    Ensures(left == right)
    Ensures(Result())
    return True
>>

segments_eq_lemma_boolean(sTypeName, nBitSize) ::= <<
@Pure
@Opaque
@staticmethod
def segments_eq_lemma(left: '<sTypeName>', right: '<sTypeName>') -> bool:
    Requires(left.is_constraint_valid_pure() and right.is_constraint_valid_pure())
    Requires(<sTypeName>.segments_of(left) == <sTypeName>.segments_of(right))
    Ensures(left == right)
    Ensures(Result())
    return left.value == right.value
>>

segments_eq_lemma_enum(sTypeName, nBitSize) ::= <<
@Pure
@Opaque
@staticmethod
def segments_eq_lemma(left: '<sTypeName>', right: '<sTypeName>') -> bool:
    Requires(left.is_constraint_valid_pure() and right.is_constraint_valid_pure())
    Requires(<sTypeName>.segments_of(left) == <sTypeName>.segments_of(right))
    Ensures(left == right)
    Ensures(Result())
    return left.val == right.val
>>

segments_eq_octetString(sTypeName, sArrName) ::= <<
@Pure
@Opaque
@staticmethod
def segments_eq_lemma(left: '<sTypeName>', right: '<sTypeName>') -> bool:
    Requires(Rd(left.class_predicate()) and left.is_constraint_valid_pure())
    Requires(Rd(right.class_predicate()) and right.is_constraint_valid_pure())
    Requires(<sTypeName>.segments_of(left) == <sTypeName>.segments_of(right))
    Ensures(left == right)
    Ensures(Result())

    Unfold(Rd(left.class_predicate()))
    Unfold(Rd(right.class_predicate()))
    left_seq = ToByteSeq(left.<sArrName>)
    right_seq = ToByteSeq(right.<sArrName>)
    Assert(lemma_segments_byteseq_full_equal(left_seq, right_seq))
    Assert(left_seq == right_seq)
    Assert(Forall(int, lambda i: Implies(0 \<= i and i \< len(left.arr), left.arr[i] == right.arr[i])))
    return left.<sArrName> == right.<sArrName>
>>

/*
*****************************************************************************************
 I S   V A L I D   P U R E   F U N C T I O N S
*****************************************************************************************
*/

is_constraint_valid_pure_expr(sTypeName, expr) ::= <<
@Pure
def is_constraint_valid_pure(self) -> bool:
    Requires(Rd(self.class_predicate()))
    Unfold(Rd(self.class_predicate()))
    return <expr>
>>

is_constraint_valid_pure_true(sTypeName) ::= <<
<is_constraint_valid_pure_expr(sTypeName=sTypeName, expr="True")>
>>

is_constraint_valid_pure_sequence(sTypeName, arrsChildren) ::= <<
@Pure
def is_constraint_valid_pure(self) -> bool:
    Requires(Rd(self.class_predicate()))
    Unfold(Rd(self.class_predicate()))
    return <arrsChildren:{child|<child>}; separator=" and ">
>>

is_constraint_valid_pure_child_mandatory(sChildName, sChildType, bIsPrimitive) ::= <<
<if(bIsPrimitive)>
(True)
<else>
self.<sChildName>.is_constraint_valid_pure()
<endif>
>>

is_constraint_valid_pure_child_optional(sChildName, sChildType, bIsPrimitive) ::= <<
<if(bIsPrimitive)>
(self.<sChildName> is None or True)
<else>
(self.<sChildName> is None or self.<sChildName>.is_constraint_valid_pure())
<endif>
>>

is_constraint_valid_pure_child_sequenceof(sChildName, sChildType, bIsPrimitive) ::= <<>>

is_constraint_valid_pure_child_choice(sChildName, sChildType) ::= <<>>

is_constraint_valid_pure_octetString(sTypeName, sArrName, sArrLength, soExpr) ::= <<
@Pure
def is_constraint_valid_pure(self) -> bool:
    Requires(Rd(self.class_predicate()))
    Unfold(Rd(self.class_predicate()))
    <if(soExpr)>
    return (<soExpr> and
            len(self.<sArrName>) == <sArrLength> and 
            Forall(self.<sArrName>, lambda i: 0 \<= i and i \< 256))
    <else>
    return (len(self.<sArrName>) == <sArrLength> and
            Forall(self.<sArrName>, lambda i: 0 \<= i and i \< 256))
    <endif>
>>