group init_python;

rtlModuleName() ::= "pythonasn1rtl"
methodNameSuffix() ::= "_Initialize"

initTypeAssignment_def(sVarName, sStar, sFuncName, sTypeDefName) ::= << >>

initTypeAssignment(sVarName, sPtrPrefix, sPtrSuffix, sFuncName, sTypeDefName, sContent, arrsLocalVariables, sDefaultInitValue, arrsAnnots) ::= <<
<sFuncName>: <sTypeDefName> = <sDefaultInitValue>
# TODO: Remove old Scala Code (init_python.stg:10-12):
# <arrsAnnots:{ann|@<ann>}; separator=" ">
# <sFuncName>: <sTypeDefName> = <sDefaultInitValue>
>>

initInteger(sVal, sValue, bIsOptional, sResVar) ::= <<
# initInteger
<if(bIsOptional)>
<sResVar> = <sValue>
# TODO: Remove old Scala Code (init_python.stg:19):
# val <sResVar> = SomeMut(<sValue>)
<else>
<sResVar> = <sValue>
# TODO: Remove old Scala Code (init_python.stg:23):
# val <sResVar> = <sValue>
<endif>
>>

initReal(sVal, dValue, bIsOptional, sResVar) ::= <<
# initReal
<if(bIsOptional)>
<sResVar> = <dValue>
# TODO: Remove old Scala Code (init_python.stg:32):
# val <sResVar> = SomeMut(<dValue>)
<else>
<sResVar> = <dValue>
# TODO: Remove old Scala Code (init_python.stg:36):
# val <sResVar> = <dValue>
<endif>
>>

initBoolean(sVal, bValue, bIsOptional, sResVar) ::= <<
# initBoolean
<if(bIsOptional)>
<sResVar> = <if(bValue)>True<else>False<endif>
# TODO: Remove old Scala Code (init_python.stg:45):
# val <sResVar> = SomeMut(<if(bValue)>true<else>false<endif>)
<else>
<sResVar> = <if(bValue)>True<else>False<endif>
# TODO: Remove old Scala Code (init_python.stg:49):
# val <sResVar> = <if(bValue)>true<else>false<endif>
<endif>
>>

initObjectIdentifier_valid(p, sAcc, sI, nIntVal) ::= "<p><sAcc>values[<sI>] = <nIntVal>"
initObjectIdentifier(p, sAcc, nSize, arrsValues) ::= <<
<p><sAcc>nCount = <nSize>
<arrsValues; separator="\n">
>>

init_Asn1LocalTime(p, sAcc, tv/*:Asn1TimeValue*/) ::= <<
<p><sAcc>hours = <tv.hours>
<p><sAcc>mins = <tv.mins>
<p><sAcc>sec = <tv.secs>
<p><sAcc>fraction = <tv.secsFraction>
>>

init_Asn1UtcTime(p, sAcc, tv/*:Asn1TimeValue*/) ::= <<
<p><sAcc>hours = <tv.hours>
<p><sAcc>mins = <tv.mins>
<p><sAcc>sec = <tv.secs>
<p><sAcc>fraction = <tv.secsFraction>
>>


init_Asn1LocalTimeWithTimeZone(p, sAcc, tv/*:Asn1TimeValue*/, tz/*:Asn1TimeZoneValue*/) ::= <<
<p><sAcc>hours = <tv.hours>
<p><sAcc>mins = <tv.mins>
<p><sAcc>sec = <tv.secs>
<p><sAcc>fraction = <tv.secsFraction>
<p><sAcc>tz.sign = <tz.sign>
<p><sAcc>tz.hours = <tz.hours>
<p><sAcc>tz.mins = <tz.mins>
>>

init_Asn1Date(p, sAcc, dt/*:Asn1DateValue*/) ::= <<
<p><sAcc>years = <dt.years>
<p><sAcc>months = <dt.months>
<p><sAcc>days = <dt.days>
>>

init_Asn1Date_LocalTime(p, sAcc, dt/*:Asn1DateValue*/, tv/*:Asn1TimeValue*/) ::= <<
<init_Asn1Date(p=p, sAcc=sAcc, dt=dt)>
<init_Asn1LocalTime(p=p, sAcc=sAcc, tv=tv)>
>>

init_Asn1Date_UtcTime(p, sAcc, dt/*:Asn1DateValue*/, tv/*:Asn1TimeValue*/) ::= <<
<init_Asn1Date(p=p, sAcc=sAcc, dt=dt)>
<init_Asn1UtcTime(p=p, sAcc=sAcc, tv=tv)>
>>

init_Asn1Date_LocalTimeWithTimeZone(p, sAcc, dt/*:Asn1DateValue*/, tv/*:Asn1TimeValue*/, tz/*:Asn1TimeZoneValue*/) ::= <<
<init_Asn1Date(p=p, sAcc=sAcc, dt=dt)>
<init_Asn1UtcTime(p=p, sAcc=sAcc, tv=tv, tz=tz)>
>>

assignAny(p, sValue, sTypeDecl) ::= "<p> = <sValue>"
assignString(p, sValue) ::= "<p> = <sValue>"


initIA5String(sPtr, sValue, bIsOptional, sResVar) ::= <<
<if(bIsOptional)>
<sResVar> = <sValue>
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar> = SomeMut(<sValue>)
<else>
<sResVar> = <sValue>
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar> = <sValue>
<endif>
>>

initEnumerated(sVal, sValue, sTypeDefName, bIsOptional, sResVar) ::= <<
<if(bIsOptional)>
<sResVar>: Optional[<sTypeDefName>] = <sValue>
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar>: OptionMut[<sTypeDefName>] = SomeMut(<sValue>)
<else>
<sResVar>: <sTypeDefName> = <sValue>
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar>: <sTypeDefName> = <sValue>
<endif>
>>

initNull(sVal, bIsOptional, sResVar) ::= <<
<if(bIsOptional)>
<sResVar>: Optional[NullType] = None
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar>: OptionMut[NullType] = SomeMut(0)
<else>
<sResVar>: NullType = None
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar>: NullType = 0
<endif>
>>

initTestCaseIA5String(p, sAcc, nSize, nMaxSizePlusOne, i, td/*:FE_StringTypeDefinition*/, bAlpha, arrnAlphabetAsciiCodes, nAlphabetLength, bZero, sResVar) ::= <<
<if(bZero)>
<sResVar> = [0] * <nMaxSizePlusOne>
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar> = Vector.fill(<nMaxSizePlusOne>)(UByte.fromRaw(0))
<else>
<if(bAlpha)>
allowed_char_set = [<arrnAlphabetAsciiCodes:{ch|0x<ch;format="X2">}; wrap, anchor, separator=", ">]
<sResVar> = [(0 if <i> == <nMaxSizePlusOne> - 1 else allowed_char_set[<i> % <nAlphabetLength>]) for <i> in range(<nSize>)] + [0]
# TODO: Remove old Scala Code (init_python.stg):
# val allowedCharSet: Array[UByte] = Array(<arrnAlphabetAsciiCodes:{ch|0x<ch;format="X2">.toRawUByte}; wrap, anchor, separator=",">)
# val <sResVar>_tmp = scala.collection.immutable.Vector.tabulate(<nSize>)(<i> => if <i> == <nMaxSizePlusOne> - 1 then UByte.fromRaw(0) else allowedCharSet(<i> % <nAlphabetLength>))
# val <sResVar> = Vector.fromScala(<sResVar>_tmp :+ UByte.fromRaw(0))
<else>
<sResVar> = [(0 if <i> == <nMaxSizePlusOne> - 1 else (ord('A') if <i> % 128 == 0 else <i> % 128)) for <i> in range(<nSize>)] + [0]
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar>_tmp = scala.collection.immutable.Vector.tabulate(<nSize>)(<i> => UByte.fromRaw(if <i> == <nMaxSizePlusOne> - 1 then 0.toByte else if <i> % 128 == 0 then 'A'.toByte else (<i> % 128).toByte))
# val <sResVar> = Vector.fromScala(<sResVar>_tmp :+ UByte.fromRaw(0))
<endif>
<endif>
>>

/* BIT AND OCTET STRINGS */

initBitOrOctStringFromCompoundLiteral(p, sCompLiteral) ::= "<p> = <sCompLiteral>"

initFixSizeBitOrOctString_bytei(p, sAcc, sI, sByteHexVal) ::= "<p><sAcc>arr[<sI>] = 0x<sByteHexVal>"
initFixSizeBitOrOctString(p, sAcc,arrsBytes) ::= <<
<arrsBytes; separator="\n">
>>

initFixVarSizeBitOrOctString(p, sAcc, nSize, arrsBytes) ::= <<
<p><sAcc>nCount = <nSize>
<arrsBytes; separator="\n">
>>

initTestCaseOctetString(p, sAcc, sArrayHolderName, nSize, i, bIsFixedSize, bZero, nMinSize, bZeroSizedArray, sResVar) ::= <<
<if(bZero)>
<sResVar> = <sArrayHolderName>(<if(!bIsFixedSize)><nMinSize>, <endif>[0] * <nSize>)
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar> = <sArrayHolderName>(<if(!bIsFixedSize)><nMinSize>, <endif>Vector.fill(<nSize>)(0.toRawUByte))
<else>
<sResVar> = <sArrayHolderName>(<if(!bIsFixedSize)><nSize>, <endif>[<i> % 256 for <i> in range(<nSize>)])
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar>_tmp = scala.collection.immutable.Vector.tabulate(<nSize>)(<i> => UByte.fromRaw((<i> % 256).toByte))
# val <sResVar> = <sArrayHolderName>(<if(!bIsFixedSize)><nSize>, <endif>Vector.fromScala(<sResVar>_tmp))
<endif>
>>


initTestCaseBitString(p, sAcc, sArrayHolderName, nSize, nSizeCeiled, i, bIsFixedSize, bZero, nMinSize, bIsOptionalField, sResVar) ::= <<
<if(bZero)>
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar> = <sArrayHolderName>(<if(!bIsFixedSize)><nMinSize>, <endif>Vector.fill(<nSizeCeiled>/8)(0.toRawUByte))
<sResVar> = <sArrayHolderName>(<if(!bIsFixedSize)><nMinSize>, <endif>[0] * (<nSizeCeiled> // 8))
<else>
<if(bIsOptionalField)>
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar>: OptionMut[<sArrayHolderName>] = SomeMut(<sArrayHolderName>(<if(!bIsFixedSize)><nSize>, <endif>Vector.fill(<nSizeCeiled> / 8)(UByte.fromRaw(0x55))))
<sResVar>: Optional[<sArrayHolderName>] = <sArrayHolderName>(<if(!bIsFixedSize)><nSize>, <endif>[0x55] * (<nSizeCeiled> // 8))
<else>
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar> = <sArrayHolderName>(<if(!bIsFixedSize)><nSize>, <endif>Vector.fill(<nSizeCeiled> / 8)(UByte.fromRaw(0x55)))
<sResVar> = <sArrayHolderName>(<if(!bIsFixedSize)><nSize>, <endif>[0x55] * (<nSizeCeiled> // 8))
<endif>
<endif>
>>



/*SEQUENCE OF */

/*dummy in C*/
initSequence_pragma(p) ::= ""


initFixedSequenceOf(arrsInnerValues) ::= <<
<arrsInnerValues; separator="\n">
>>


initVarSizeSequenceOf(p, sAcc, nSize, arrsInnerValues) ::= <<
<p><sAcc>nCount = <nSize>
<arrsInnerValues; separator="\n">
>>


initTestCaseSizeSequenceOf_innerItem(bFirst, bLastItem, nCaseIdx, sChildCaseInit, i, nCaseLen, sResVar) ::= <<
<if(!bLastItem)><if(bFirst)>if<else>elif<endif> <i> % <nCaseLen> == <nCaseIdx>:<else>else:<endif>
    <sChildCaseInit>
    <sResVar>
>>

initTestCaseSizeSequenceOf(p, sAcc, sArrayHolderName, noMinSize, nSize, bIsFixedSize, arrsInnerItems, bMultiCases, i, sResVar) ::= <<
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar>_vec = scala.collection.immutable.Vector.tabulate(<nSize>) { <i> =>
#     <arrsInnerItems; separator="\n">
# }
# val <sResVar> = <sArrayHolderName>(<if(!bIsFixedSize)><if(noMinSize)><noMinSize><else><nSize><endif>, <endif>Vector.fromScala(<sResVar>_vec))
<sResVar>_list = []
for <i> in range(<nSize>):
    <arrsInnerItems; separator="\n">
    <sResVar>_list.append(<sResVar>)
<sResVar> = <sArrayHolderName>(<if(!bIsFixedSize)><if(noMinSize)><noMinSize><else><nSize><endif>, <endif><sResVar>_list)
>>


/*SEQUENCE*/

initSequence_optionalChild(p, sAcc, sChName, sPresentFlag, sChildContent) ::=<<
# TODO: Remove old Scala Code (init_python.stg):
# <p><sAcc>exist.<sChName> = if <sPresentFlag> == 0 then false else true
<p><sAcc>exist.<sChName> = False if <sPresentFlag> == 0 else True
<sChildContent>
>>

initSequence(arrsInnerValues) ::= <<
<arrsInnerValues; separator="\n">
>>

initSequence_emptySeq(p) ::= ""

initTestCase_sequence_child(p, sAcc, sChName, sChildContent, bOptional, sInitExpr) ::= <<
<sChildContent>
>>

initTestCase_sequence_child_opt(p, sAcc, sChName, sChildTypedef, sResVar) ::= <<
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar>: OptionMut[<sChildTypedef>] = NoneMut()
<sResVar>: Optional[<sChildTypedef>] = None
>>

initChoice(p, sAcc, sChildContent, sChildID, sChildName, sChildTypeName, sChoiceTypeName, sChildTempVarName, sChildTempDefaultInit, bComponentTempInit) ::= <<
# TODO: Remove old Scala Code (init_python.stg):
# var <sChildTempVarName>: <sChildTypeName> = <sChildTempDefaultInit>
<sChildTempVarName>: <sChildTypeName> = <sChildTempDefaultInit>
<sChildContent>
<p> = <sChildID>(<sChildTempVarName>)
>>

initTestCase_choice_child(p, sAcc, sChildContent, sChildID, sChildName, sChildTypeName, sChoiceTypeName, sChildTempVarName, sChildTempDefaultInit, bIsOptional, sResVar) ::= <<
<sChildContent>
<if(bIsOptional)>
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar> = SomeMut(<sChildID>(<sChildTempVarName>))
<sResVar> = <sChildID>(<sChildTempVarName>)
<else>
# TODO: Remove old Scala Code (init_python.stg):
# val <sResVar> = <sChildID>(<sChildTempVarName>)
<sResVar> = <sChildID>(<sChildTempVarName>)
<endif>
>>

initChildWithInitFunc(p, sChildInitFuncName) ::= <<
<p> = <sChildInitFuncName>()
>>


initBitStringAtPos(sVarName, sStar, sFuncName, sTypeDefName, sNamedBit, nZeroBasedByteIndex, sHexByteMax, nZeroBasedBitIndex) ::= <<
# TODO: Remove old C Code (init_python.stg):
# void <sFuncName>_set_<sNamedBit>(<sTypeDefName><sStar> <sVarName>) /*COVERAGE_IGNORE*/
# {
#     <sVarName>->arr[<nZeroBasedByteIndex>] |= <sHexByteMax>; /*COVERAGE_IGNORE*/
# }
def <sFuncName>_set_<sNamedBit>(<sVarName>: <sTypeDefName>) -> None:
    <sVarName>.arr[<nZeroBasedByteIndex>] |= <sHexByteMax>
>>

initBitStringAtPos_def(sVarName, sStar, sFuncName, sTypeDefName, sNamedBit) ::= <<
# TODO: Remove old C Code (init_python.stg):
# void <sFuncName>_set_<sNamedBit>(<sTypeDefName><sStar> <sVarName>);
def <sFuncName>_set_<sNamedBit>(<sVarName>: <sTypeDefName>) -> None: ...
>>

initTypeConstant_def(sTypeDecl, sConstantName, sValue) ::= <<
# TODO: Remove old Scala Code (init_python.stg):
# val <sConstantName>: <sTypeDecl> = <sValue>
<sConstantName>: <sTypeDecl> = <sValue>
>>

initTypeConstant_body(sTypeDecl, sConstantName, sValue) ::= <<
# TODO: Remove old Scala Code (init_python.stg):
# val <sConstantName>: <sTypeDecl> = <sValue>
<sConstantName>: <sTypeDecl> = <sValue>
>>

initFixSizeOctetString(sTypeDefName, nMax, bZeroSizedArray) ::= "<sTypeDefName>([0] * <nMax>)"
initVarSizeOctetString(sTypeDefName, nMin, nMax) ::= "<sTypeDefName>(<nMin>, [0] * <nMax>)"

initFixSizeBitString(sTypeDefName, nMax, nMaxOctets) ::= "<sTypeDefName>([0] * <nMaxOctets>)"
initVarSizeBitString(sTypeDefName, nMin, nMax, nMaxOctets) ::= "<sTypeDefName>(<nMin>, [0] * <nMaxOctets>)"

initFixSizeSequenceOfExpr(sTypeDefName, nMax, sChildExp) ::= "<sTypeDefName>([<sChildExp>] * <nMax>)"
initVarSizeSequenceOfExpr(sTypeDefName, nMin, nMax, sChildExp) ::= "<sTypeDefName>(<nMin>, [<sChildExp>] * <nMax>)"


initObjectIdentifierAsExpr() ::= <<
# TODO: Remove old C Code (init_python.stg):
# {.nCount = 0, .values  = {[0 ... OBJECT_IDENTIFIER_MAX_LENGTH-1] = 0 }}
{"nCount": 0, "values": [0] * OBJECT_IDENTIFIER_MAX_LENGTH}
>>

init_Asn1LocalTimeExpr() ::= <<
# TODO: Remove old C Code (init_python.stg):
# {.hours = 0, .mins = 0, .sec = 0, .fraction = 0}
{"hours": 0, "mins": 0, "sec": 0, "fraction": 0}
>>

init_Asn1UtcTimeExpr() ::= <<
# TODO: Remove old C Code (init_python.stg):
# {.hours = 0, .mins = 0, .sec = 0, .fraction = 0}
{"hours": 0, "mins": 0, "sec": 0, "fraction": 0}
>>


init_Asn1LocalTimeWithTimeZoneExpr() ::= <<
# TODO: Remove old C Code (init_python.stg):
# {.hours = 0, .mins = 0, .sec = 0, .fraction = 0, .tz.sign = 0, .tz.hours = 0, .tz.mins = 0}
{"hours": 0, "mins": 0, "sec": 0, "fraction": 0, "tz": {"sign": 0, "hours": 0, "mins": 0}}
>>

init_Asn1DateExpr() ::= <<
# TODO: Remove old C Code (init_python.stg):
# {.years = 0, .months = 0, .days = 0}
{"years": 0, "months": 0, "days": 0}
>>

init_Asn1Date_LocalTimeExpr() ::= <<
# TODO: Remove old C Code (init_python.stg):
# {.years = 0, .months = 0, .days = 0, .hours = 0, .mins = 0, .sec = 0, .fraction = 0}
{"years": 0, "months": 0, "days": 0, "hours": 0, "mins": 0, "sec": 0, "fraction": 0}
>>

init_Asn1Date_UtcTimeExpr() ::= <<
# TODO: Remove old C Code (init_python.stg):
# {.years = 0, .months = 0, .days = 0, .hours = 0, .mins = 0, .sec = 0, .fraction = 0}
{"years": 0, "months": 0, "days": 0, "hours": 0, "mins": 0, "sec": 0, "fraction": 0}
>>

init_Asn1Date_LocalTimeWithTimeZoneExpr() ::= <<
# TODO: Remove old C Code (init_python.stg):
# {.years = 0, .months = 0, .days = 0, .hours = 0, .mins = 0, .sec = 0, .fraction = 0, .tz.sign = 0, .tz.hours = 0, .tz.mins = 0 }
{"years": 0, "months": 0, "days": 0, "hours": 0, "mins": 0, "sec": 0, "fraction": 0, "tz": {"sign": 0, "hours": 0, "mins": 0}}
>>

initSequenceChildExpr(sChildName, sChildExpr, bIsOptional, bIsAbsent) ::= <<
<if(bIsOptional)>
<if(bIsAbsent)>
# TODO: Remove old Scala Code (init_python.stg):
# <sChildName> = NoneMut()
<sChildName> = None
<else>
# TODO: Remove old Scala Code (init_python.stg):
# <sChildName> = SomeMut(<sChildExpr>)
<sChildName> = <sChildExpr>
<endif>
<else>
<sChildName> = <sChildExpr>
<endif>
>>
initSequenceOptionalChildExpr(sChildName, nPresenceBit) ::= "<sChildName> = False if <nPresenceBit> == 0 else True"
initSequenceExpr(sTypeDefName, arrsChildren, arrsOptionalChildren) ::= <<
<sTypeDefName>(<arrsChildren; separator=", ">)
>>

initChoiceExpr(sChildName, sChildKind, sChildExpr) ::= "<sChildKind>(<sChildExpr>)"
