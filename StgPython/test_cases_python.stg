group test_cases_python;

rtlModuleName() ::= ""


PrintAutomaticTestCasesSpecFile(sModNameUpperCase, sModName, arrsIncludedModules, arrsTestFunctions) ::= <<
# test_cases_python.stg:18
"""
Code automatically generated by asn1scc tool
"""
from asn1python import *
from <sModName> import *


>>


PrintAutomaticTestCasesBodyFile(sModName, sTetscaseSpecFileName, arrsIncludedModules, arrsTasNames, arrsTypeAssignments, bXer) ::= <<
# test_cases_python.stg:29
"""
Code automatically generated by asn1scc tool
"""


<arrsTypeAssignments:{tas|<tas>}; separator="\n">
>>

/* Encode Decode start*/

Codec_Encode(sModName, sFuncName, sVal) ::= <<
# test_cases_python.stg:54
# Encode value
# TODO: that this code works, we have to have a res object with is_left() and a Left(..) method.
res = <sFuncName>(<sVal>, codec, True)
if res.is_left():
    return Left(1)
>>

Codec_Decode(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
# test_cases_python.stg:62
codec.base.bit_stream.reset_bit_index()
# Decode value
res = <sFuncName>(codec)

if res.is_left_mut():
    return Left(2)
elif res.is_right_mut(pVal):
    decodedPDU = pVal
>>

Codec_Decode_XER(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
# test_cases_python.stg:71
bit_stream.attach_buffer(enc_buff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING)
# Decode value
res = <sFuncName>()

if res.is_left():
    return Left(2)
elif res.is_right(pVal):
    decodedPDU = pVal
>>

Codec_validate_output(sModName, sFuncName, sAmber) ::= <<
# test_cases_python.stg:80
# validate decoded data
res = <sFuncName>(decodedPDU)

if res.is_left():
    return Left(3)
>>

Codec_compare_input_with_output(sModName, sFuncName, sVal, sAmber) ::= <<
# test_cases_python.stg:88
if not <sFuncName>(<sVal>, decodedPDU):
    return Left(4)
>>

Codec_write_CharstreamToFile() ::= <<
# test_cases_python.stg:94
<Codec_write_bitstreamToFile()>
>>

Codec_write_bitstreamToFile() ::= <<
# test_cases_python.stg:99
codec.base.bitStream.resetBitIndex()
with open(filename+".dat", "wb") as fp:
    fp.write(codec.base.bitStream.buf.toArrayRaws)
>>

JoinItems(sPart, soNestedPart) ::= <<
# test_cases_python.stg:107
<sPart>
<if(soNestedPart)>
<soNestedPart>
<endif>
>>


Codec_declare_EncInDecOut_variable(sPrmName, sType, sPrmValue) ::= <<
# test_cases_python.stg:116
<sType> enc_<sPrmName> = <sPrmValue>;
<sType> dec_<sPrmName>;
>>

Codec_declare_DecIn_variable(sPrmName, sType) ::= "<sType> dec_<sPrmName>; # test_cases_python.stg:122 "


PrintCodec_spec(sFuncName, sModName, sTasName, sStar, sVal) ::= <<
# test_cases_python.stg:125
>>

PrintCodec_body(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements, sCodecClass) ::= <<
# test_cases_python.stg:129
def <sFuncName>(<sVal>: <sTasName>, filename: str) -> Either[int]:
    ret: Either[int] = Right(0)
    decodedPDU: <sTasName> = <sTasName>_Initialize() # TODO: does this always work?

    codec = <sCodecClass>Codec(int(<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING))
    <sNestedStatements>
    return ret
>>

PrintCodec_body_XER(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
# test_cases_python.stg:142 TODO: unclear where flag comes from and what to do with that
flag <sFuncName>(const <sTasName><sStar> <sVal>, int* pErrCode, const char* filename)
{
    static <sTasName> decodedPDU;
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; # +1 for zerosized types
    ByteStream bitStrm;
    flag ret = TRUE;

    ByteStream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    <sNestedStatements>
    return ret;
}
>>






/* Encode Decode End*/

PrintMain(sTestSuiteFilename) ::= <<
# test_cases_python.stg:164
from asn1python import *
    
def printf_tests_failed(testCount: int, failedCount: int):
    print(f"[test failed] {failedCount} out of {testCount} failed.")


def printf_tests_passed(testCount: int):
    print(f"[test success] All test cases ({testCount}) run successfully.")


def printf_null() -> Unit:
    # TODO: what to do here?
    pass
    
def printf_null_char(s: str) =
    # TODO: what to do here?
    pass

def printf_message(message: str) =
    print(f"{message}")

def print_test_case_success(message: str, duration: Long):
    print(f"test case '{message}' succeeded, duration was \t\t\t\t{duration} ms")

def main():
    output = TestOutput(
        report_tests_failed = printf_tests_failed,
        report_all_tests_passed = printf_tests_passed,
        report_suite_begin = printf_null,
        report_suite_end = printf_null,
        report_case_begin = printf_null_char,
        report_case_end = printf_null,
        report_failure_begin = printf_null,
        report_failure_end = printf_null,
        report_failure_message = printf_message,
        report_test_case_success = print_test_case_success
    )

    res = asn1scc_run_generated_testsuite(output)
    System.exit(res)
>>





PrintSuite_call_codec_generate_dat_file(sModName, sTasName, sAmber, sEnc, sStreamName) ::= <<
# TODO: test_cases_python.stg:221
if result:
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1] # +1 for zerosized types
    bitStrm: <sStreamName>Stream
    <sStreamName>Stream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    
    result = <sTasName>_<sEnc>Encode(<sAmber>tmp, &bitStrm, &errCode, TRUE);
    
    if not os.path.exists("asn1scc_<sEnc>.dat"):
        print("fopen failed !!!\n");
        return None;
    
    with open("asn1scc_<sEnc>.dat","wb") as fp:
        fp.write(encBuff)
>>

PrintATCRunnerDefinition() ::= <<
# test_cases_python.stg:246
from asn1python import *
from dataclasses import dataclass

#dataclass
class TestOutput:
    report_tests_failed: Callable[[int, int], None]
    report_all_tests_passed: Callable[[int], None]

    report_suite_begin: Callable[[], None]
    report_suite_end: Callable[[], None]

    report_case_begin: Callable[[str], None]
    report_case_end: Callable[[], None]

    report_failure_begin: Callable[[], None]
    report_failure_end: Callable[[], None]
    report_failure_message: Callable[[str], None]
    report_test_case_success: Callable[[str, Long], None]
>>

PrintATCRunner(sTestSuiteFilename, arrsIncludedModules, arrsVars, arrsTestFunctions, arrsUsedPackages, arrsInitCalls, bGenerateDatFile) ::= <<
# test_cases_python.stg:268
# Code automatically generated by asn1scc tool (stg macro : PrintATCRunner)
from asn1python import *

def asn1scc_run_generated_testsuite(output: TestOutput) -> int
    totalErrors: int = 0
    <arrsVars; separator="\n">


    output.report_suite_begin()

    # test_cases_python.stg:282
    <arrsTestFunctions;separator="\n\n">

    output.report_suite_end()

    if totalErrors > 0:
        output.report_tests_failed(<arrsTestFunctions.Length>, totalErrors)
        return 1
    else:
        output.report_all_tests_passed(<arrsTestFunctions.Length>)
        return 0
>>



invokeTestCaseAsFunc(sFuncName) ::= <<
# test_cases_python.stg:301
totalErrors += <sFuncName>(output)
>>


emitTestCaseAsFunc_h(sFuncName) ::= <<
>>

emitTestCaseAsFunc_dummy_init(sTypeName, sFuncName, sDummyVarname) ::= <<
# test_cases_python.stg:310
<sDummyVarname>: <sTypeName> = <sFuncName>()
>>

emitTestCaseAsFunc_dummy_init_function(sTypeName, sFuncName, sDummyVarname) ::= <<
# test_cases_python.stg:315
<sDummyVarname>: <sTypeName> = <sFuncName>()
>>

emitTestCaseAsFunc(sFuncName, arrsVars, sModName, sTasName, sAmber, sEnc, bValueAssignment, sInitializeTcData, bStatic, sGenerateDatFile, arrsDummyInitStatementsNeededForStatementCoverage, sInitAmber) ::= <<
# test_cases_python.stg:320
import time
def <sFuncName>(output: TestOutput) -> int:
    totalErrors: int = 0
    result: Either = Left(NOT_INITIALIZED_ERR_CODE)
    <arrsVars; separator="\n">

    output.report_case_begin("<sFuncName>")

    <sInitializeTcData>

    start = int(time.time() * 1000)
    result = <sTasName>_<sEnc>enc_dec(tc_data, "<sFuncName>")
    stop = int(time.time() * 1000)
    match result:
        case Right(_):
            output.report_test_case_success("<sTasName>/<sFuncName>", stop - start)
        case Left(errorCode):
            output.report_failure_begin()
            match errorCode:
                case 1:
                    # TODO: ATC may generate invalid messages that get rejected when encoding.
                    # This typically happens for determinants shared across multiple choices within a sequence.
                    # As such, we do not count it as an error.
                    # Note that the Ada and C backend do not always propagate errors when encoding fail,
                    # therefore they are "unaffected" by this bug.
                    output.report_failure_message("!!!!! Test case '<sTasName>/<sFuncName>' failed in encoding.")
                case 2:
                    output.report_failure_message("Test case '<sTasName>/<sFuncName>' failed in decoding.")
                    totalErrors = totalErrors + 1
                case 3:
                    output.report_failure_message("Test case '<sTasName>/<sFuncName>' failed in the validation of the decoded message.")
                    totalErrors = totalErrors + 1
                case 4:
                    output.report_failure_message("Test case '<sTasName>/<sFuncName>' failed. Encoded and decoded messages are different.")
                    totalErrors = totalErrors + 1
                case _ :
                    output.report_failure_message("Unexpected error code in test case '<sFuncName>'.")
                    totalErrors = totalErrors + 1
            output.report_failure_message("========================================")
            output.report_failure_end()

    <sGenerateDatFile>

    output.report_case_end()
    totalErrors
>>


printTestCaseFileDef(sThisFile, arrsIncludedModules, arrsTestFunctionDefs) ::= <<
"""
Code automatically generated by asn1scc tool
"""
from asn1python import *
>>


printTestCaseFileBody(sThisFile, arrsIncludedModules, arrsTestFunctionBodies) ::= <<
# Code automatically generated by asn1scc tool (stg macro : printTestCaseFileBody)
from asn1python import *

<arrsTestFunctionBodies;separator="\n\n">

>>
