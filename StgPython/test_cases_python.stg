group test_cases_python;

rtlModuleName() ::= ""


PrintAutomaticTestCasesSpecFile(sModNameUpperCase, sModName, arrsIncludedModules, arrsTestFunctions) ::= <<>>


PrintAutomaticTestCasesBodyFile(sModName, sTetscaseSpecFileName, arrsIncludedModules, arrsTasNames, arrsTypeAssignments, bXer) ::= <<
# test_cases_python.stg:29
"""
Code automatically generated by asn1scc tool
"""
from ..asn1python import *
<arrsIncludedModules:{aim|from .<aim> import *}; separator="\n">

<arrsTypeAssignments:{tas|<tas>}; separator="\n\n">
>>

/* Encode Decode start*/

Codec_Encode(sModName, sFuncName, sVal) ::= <<
# test_cases_python.stg:54
res = <sVal>.encode(codec, True)
if not res:
    # test_cases_python.stg 35
    return res
>>

Codec_Decode(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
# test_cases_python.stg:62

decoder = encoder.get_decoder()

# Decode value
res = <sTasName>.decode(decoder)

if not res:
    # test_cases_python.stg 45
    return res
decodedPDU = res
>>

// todo: Implement XER Decoding routines
Codec_Decode_XER(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
# test_cases_python.stg:71
bit_stream.attach_buffer(enc_buff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING)
# Decode value
res = <sFuncName>()

if not res:
    # test_cases_python.stg 57
    return res
elif res == pVal:
    decodedPDU = pVal
>>

Codec_validate_output(sModName, sFuncName, sAmber) ::= <<
# test_cases_python.stg:80
res = decodedPDU.<sFuncName>()

if not res:
    # test_cases_python.stg 68
    return res
>>

Codec_compare_input_with_output(sModName, sFuncName, sVal, sAmber) ::= <<
# test_cases_python.stg:88
if not <sVal> == decodedPDU:
    # test_cases_python.stg 74
    return Asn1SccError(4)
>>

Codec_write_CharstreamToFile() ::= <<
# test_cases_python.stg:94
<Codec_write_bitstreamToFile()>
>>

Codec_write_bitstreamToFile() ::= <<
# test_cases_python.stg:99
with open(f"{filename}.dat", "wb") as fp:
    fp.write(encoder.get_bitstream_buffer())
>>

JoinItems(sPart, soNestedPart) ::= <<
# test_cases_python.stg:107
<sPart>
<if(soNestedPart)>
<soNestedPart>
<endif>
>>

Codec_declare_EncInDecOut_variable(sPrmName, sType, sPrmValue) ::= <<
# test_cases_python.stg:116
<sType> enc_<sPrmName> = <sPrmValue>;
<sType> dec_<sPrmName>;
>>

Codec_declare_DecIn_variable(sPrmName, sType) ::= "<sType> dec_<sPrmName>; # test_cases_python.stg:122 "


PrintCodec_spec(sFuncName, sModName, sTasName, sStar, sVal) ::= <<
# test_cases_python.stg:125
>>

PrintCodec_body(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements, sCodecClass) ::= <<
# test_cases_python.stg:129
def <sFuncName>(<sVal>: <sTasName>, filename: str) -> Union[int, Asn1SccError]:
    # ret: Union[int, Asn1SccError] = 0
    # todo: is initialization necessary?
    #decodedPDU: <sTasName> = <sTasName>_Initialize()
    
    encoder = <sCodecClass>Encoder(int(<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING))
    <sNestedStatements>
    # test_cases_python.stg 119
    return ret
>>

PrintCodec_body_XER(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
# test_cases_python.stg:142
# TODO: unclear where flag comes from and what to do with that
flag <sFuncName>(const <sTasName><sStar> <sVal>, int* pErrCode, const char* filename)
{
    static <sTasName> decodedPDU;
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; # +1 for zerosized types
    ByteStream bitStrm;
    flag ret = TRUE;

    ByteStream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    <sNestedStatements>
    # test_cases_python.stg 133
    return ret;
}
>>


/* Encode Decode End*/

PrintMain(sTestSuiteFilename) ::= <<
import sys
import pathlib
sys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))

# test_cases_python.stg:164
from testsuite import asn1scc_run_generated_testsuite, TestOutput
    
def printf_tests_failed(testCount: int, failedCount: int):
    print(f"[test failed] {failedCount} out of {testCount} failed.")


def printf_tests_passed(testCount: int):
    print(f"[test success] All test cases ({testCount}) run successfully.")


def printf_null() -> None:
    pass
    
def printf_null_char(s: str):
    pass

def printf_message(message: str):
    print(f"{message}")

def print_test_case_success(message: str, duration: int):
    print(f"test case '{message}' succeeded, duration was \t\t\t\t{duration} ms")

if __name__ == "__main__":
    output = TestOutput(
        report_tests_failed = printf_tests_failed,
        report_all_tests_passed = printf_tests_passed,
        report_suite_begin = printf_null,
        report_suite_end = printf_null,
        report_case_begin = printf_null_char,
        report_case_end = printf_null,
        report_failure_begin = printf_null,
        report_failure_end = printf_null,
        report_failure_message = printf_message,
        report_test_case_success = print_test_case_success
    )

    res = asn1scc_run_generated_testsuite(output)
    System.exit(res)
>>





PrintSuite_call_codec_generate_dat_file(sModName, sTasName, sAmber, sEnc, sStreamName) ::= <<
# TODO: test_cases_python.stg:221
if result:
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1] # +1 for zerosized types
    bitStrm: <sStreamName>Stream
    <sStreamName>Stream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    
    result = <sTasName>_<sEnc>Encode(<sAmber>tmp, &bitStrm, &errCode, TRUE);
    
    if not os.path.exists("asn1scc_<sEnc>.dat"):
        print("fopen failed !!!\n");
        # test_cases_python.stg 203
        return None;
    
    with open("asn1scc_<sEnc>.dat","wb") as fp:
        fp.write(encBuff)
>>

PrintATCRunnerDefinition() ::= <<
# test_cases_python.stg:246
from dataclasses import dataclass
from typing import Callable

@dataclass
class TestOutput:
    report_tests_failed: Callable[[int, int], None]
    report_all_tests_passed: Callable[[int], None]

    report_suite_begin: Callable[[], None]
    report_suite_end: Callable[[], None]

    report_case_begin: Callable[[str], None]
    report_case_end: Callable[[], None]

    report_failure_begin: Callable[[], None]
    report_failure_end: Callable[[], None]
    report_failure_message: Callable[[str], None]
    report_test_case_success: Callable[[str, int], None]


>>

PrintATCRunner(sTestSuiteFilename, arrsIncludedModules, arrsVars, arrsTestFunctions, arrsUsedPackages, arrsInitCalls, bGenerateDatFile) ::= <<
# test_cases_python.stg:268
# Code automatically generated by asn1scc tool (stg macro : PrintATCRunner)
<arrsIncludedModules:{a|from <a> import *}; separator="\n">


def asn1scc_run_generated_testsuite(output: TestOutput) -> int:
    totalErrors: int = 0
    <arrsVars; separator="\n">


    output.report_suite_begin()

    # test_cases_python.stg:282
    <arrsTestFunctions;separator="\n">

    output.report_suite_end()

    if totalErrors > 0:
        output.report_tests_failed(<arrsTestFunctions.Length>, totalErrors)
        return 1
    else:
        output.report_all_tests_passed(<arrsTestFunctions.Length>)
        return 0
>>



invokeTestCaseAsFunc(sFuncName) ::= <<
# test_cases_python.stg:301
totalErrors += <sFuncName>(output)
>>


emitTestCaseAsFunc_h(sFuncName) ::= <<
>>

emitTestCaseAsFunc_dummy_init(sTypeName, sFuncName, sDummyVarname) ::= <<
# test_cases_python.stg:310
<sDummyVarname>: <sTypeName> = <sFuncName>()
>>

emitTestCaseAsFunc_dummy_init_function(sTypeName, sFuncName, sDummyVarname) ::= <<
# test_cases_python.stg:315
<sDummyVarname>: <sTypeName> = <sFuncName>()
>>

emitTestCaseAsFunc(sFuncName, arrsVars, sModName, sTasName, sAmber, sEnc, bValueAssignment, sInitializeTcData, bStatic, sGenerateDatFile, arrsDummyInitStatementsNeededForStatementCoverage, sInitAmber) ::= <<
# test_cases_python.stg:320

def <sFuncName>(output: TestOutput) -> int:
    from asn1pylib.asn1src import <sTasName>
    from asn1pylib.asn1src.<sModName>_auto_tcs import <sTasName>_<sEnc>enc_dec
    
    totalErrors: int = 0
    <arrsVars; separator="\n">

    output.report_case_begin("<sFuncName>")

    <sInitializeTcData>

    start = int(time.time() * 1000)
    result = <sTasName>_<sEnc>enc_dec(tc_data, "<sFuncName>")
    stop = int(time.time() * 1000)
    if not isinstance(result, Asn1SccError):
        output.report_test_case_success("<sTasName>/<sFuncName>", stop - start)
    else:
        output.report_failure_begin()
        errorcode = result.get_error_code()
        if errorcode == 1:
            # TODO: ATC may generate invalid messages that get rejected when encoding.
            # This typically happens for determinants shared across multiple choices within a sequence.
            # As such, we do not count it as an error.
            # Note that the Ada and C backend do not always propagate errors when encoding fail,
            # therefore they are "unaffected" by this bug.
            output.report_failure_message("!!!!! Test case '<sTasName>/<sFuncName>' failed in encoding.")
        elif errorcode ==  2:
            output.report_failure_message("Test case '<sTasName>/<sFuncName>' failed in decoding.")
            totalErrors = totalErrors + 1
        elif errorcode ==  3:
            output.report_failure_message("Test case '<sTasName>/<sFuncName>' failed in the validation of the decoded message.")
            totalErrors = totalErrors + 1
        elif errorcode ==  4:
            output.report_failure_message("Test case '<sTasName>/<sFuncName>' failed. Encoded and decoded messages are different.")
            totalErrors = totalErrors + 1
        else:
            output.report_failure_message("Unexpected error code in test case '<sFuncName>'.")
            totalErrors = totalErrors + 1
        output.report_failure_message("========================================")
        output.report_failure_end()

    <sGenerateDatFile>

    output.report_case_end()
    return totalErrors
>>


printTestCaseFileDef(sThisFile, arrsIncludedModules, arrsTestFunctionDefs) ::= <<>>


printTestCaseFileBody(sThisFile, arrsIncludedModules, arrsTestFunctionBodies) ::= <<
# Code automatically generated by asn1scc tool (stg macro : printTestCaseFileBody)
import time
from testsuite import TestOutput
<!<arrsIncludedModules:{aim|from .<aim> import *}; separator="\n">!>

<arrsTestFunctionBodies;separator="\n\n">

>>
