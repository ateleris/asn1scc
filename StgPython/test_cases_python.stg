group test_cases_python;

rtlModuleName() ::= ""


PrintAutomaticTestCasesSpecFile(sModNameUpperCase, sModName, arrsIncludedModules, arrsTestFunctions) ::= <<>>


PrintAutomaticTestCasesBodyFile(sModName, sTetscaseSpecFileName, arrsIncludedModules, arrsTasNames, arrsTypeAssignments, bXer) ::= <<
# test_cases_python.stg:29
"""
Code automatically generated by asn1scc tool
"""
from pathlib import Path
from asn1pylib.asn1python import *
<arrsIncludedModules:{aim|from asn1pylib.asn1src.<aim> import *}; separator="\n">

<arrsTypeAssignments:{tas|<tas>}; separator="\n\n">
>>

/* Encode Decode start*/

Codec_Encode(sModName, sFuncName, sVal) ::= <<
# test_cases_python.stg:54
<sVal>.encode(encoder, True)
>>

Codec_Decode(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
# test_cases_python.stg:62

decoder = encoder.get_decoder()

# Decode value
try:
    decodedPDU = <sTasName>.decode(decoder)
except Exception as e:
    raise Asn1TestcaseDecodeFailedError(e)

>>

// todo: Implement XER Decoding routines
Codec_Decode_XER(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
# test_cases_python.stg:71
bit_stream.attach_buffer(enc_buff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING)
# Decode value
res = <sFuncName>()

if not res:
    # test_cases_python.stg 57
    return res
elif res == pVal:
    decodedPDU = pVal
>>

Codec_validate_output(sModName, sFuncName, sAmber) ::= <<
# test_cases_python.stg:58
res = decodedPDU.<sFuncName>()
if not res:
    raise Asn1TestcaseConstraintFailedError(f"Constraint Validation Failed with Errorcode {res.error_code}: {res.message}")
>>

Codec_compare_input_with_output(sModName, sFuncName, sVal, sAmber) ::= <<
# test_cases_python.stg:65
if <sVal> != decodedPDU:
    raise Asn1TestcaseDifferentResultError()
>>

Codec_write_CharstreamToFile() ::= <<
# test_cases_python.stg:94
<Codec_write_bitstreamToFile()>
>>

Codec_write_bitstreamToFile() ::= <<
# test_cases_python.stg:99
base_path = Path("output")
base_path.mkdir(parents=True, exist_ok=True)
full_path = base_path / f"{filename}.dat"
with full_path.open(mode='wb') as fp:
    fp.write(encoder.get_bitstream_buffer())
>>

JoinItems(sPart, soNestedPart) ::= <<
# test_cases_python.stg:107
<sPart>
<if(soNestedPart)>
<soNestedPart>
<endif>
>>

Codec_declare_EncInDecOut_variable(sPrmName, sType, sPrmValue) ::= <<
# test_cases_python.stg:116
<sType> enc_<sPrmName> = <sPrmValue>;
<sType> dec_<sPrmName>;
>>

Codec_declare_DecIn_variable(sPrmName, sType) ::= "<sType> dec_<sPrmName>; # test_cases_python.stg:122 "


PrintCodec_spec(sFuncName, sModName, sTasName, sStar, sVal) ::= <<
# test_cases_python.stg:125
>>

PrintCodec_body(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements, sCodecClass) ::= <<
# test_cases_python.stg:129
def <sFuncName>(<sVal>: <sTasName>, filename: str) -> Union[int, Asn1SccError]:
    encoder = <sCodecClass>Encoder(<sTasName>.EncodeConstants.<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING)
    <sNestedStatements>
    # test_cases_python.stg 108
    return True
>>

PrintCodec_body_XER(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
# test_cases_python.stg:142
# TODO: unclear where flag comes from and what to do with that
flag <sFuncName>(const <sTasName><sStar> <sVal>, int* pErrCode, const char* filename)
{
    static <sTasName> decodedPDU;
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; # +1 for zerosized types
    ByteStream bitStrm;
    flag ret = TRUE;

    ByteStream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    <sNestedStatements>
    # test_cases_python.stg 133
    return ret;
}
>>


/* Encode Decode End*/

PrintMain(sTestSuiteFilename) ::= <<
import sys
import pathlib
sys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))

# test_cases_python.stg:164
from testsuite import asn1scc_run_generated_testsuite, TestOutput
    
def printf_tests_failed(testCount: int, failedCount: int):
    print(f"[test failed] {failedCount} out of {testCount} failed.")


def printf_tests_passed(testCount: int):
    print(f"[test success] All test cases ({testCount}) run successfully.")


def printf_null() -> None:
    pass
    
def printf_null_char(s: str):
    pass

def printf_message(message: str):
    print(f"{message}")

def print_test_case_success(message: str, duration: int):
    print(f"test case '{message}' succeeded, duration was \t\t\t\t{duration} ms")

if __name__ == "__main__":
    output = TestOutput(
        report_tests_failed = printf_tests_failed,
        report_all_tests_passed = printf_tests_passed,
        report_suite_begin = printf_null,
        report_suite_end = printf_null,
        report_case_begin = printf_null_char,
        report_case_end = printf_null,
        report_failure_begin = printf_null,
        report_failure_end = printf_null,
        report_failure_message = printf_message,
        report_test_case_success = print_test_case_success
    )

    res = asn1scc_run_generated_testsuite(output)
    System.exit(res)
>>





PrintSuite_call_codec_generate_dat_file(sModName, sTasName, sAmber, sEnc, sStreamName) ::= <<
# TODO: test_cases_python.stg:221
if result:
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1] # +1 for zerosized types
    bitStrm: <sStreamName>Stream
    <sStreamName>Stream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    
    result = <sTasName>_<sEnc>Encode(<sAmber>tmp, &bitStrm, &errCode, TRUE);
    
    if not os.path.exists("asn1scc_<sEnc>.dat"):
        print("fopen failed !!!\n");
        # test_cases_python.stg 203
        return None;
    
    with open("asn1scc_<sEnc>.dat","wb") as fp:
        fp.write(encBuff)
>>

PrintATCRunnerDefinition() ::= <<
# test_cases_python.stg:246
from dataclasses import dataclass
from typing import Callable

@dataclass
class TestOutput:
    report_tests_failed: Callable[[int, int], None]
    report_all_tests_passed: Callable[[int], None]

    report_suite_begin: Callable[[], None]
    report_suite_end: Callable[[], None]

    report_case_begin: Callable[[str], None]
    report_case_end: Callable[[], None]

    report_failure_begin: Callable[[], None]
    report_failure_end: Callable[[], None]
    report_failure_message: Callable[[str], None]
    report_test_case_success: Callable[[str, int], None]


>>

PrintATCRunner(sTestSuiteFilename, arrsIncludedModules, arrsVars, arrsTestFunctions, arrsUsedPackages, arrsInitCalls, bGenerateDatFile) ::= <<
# test_cases_python.stg:268
# Code automatically generated by asn1scc tool (stg macro : PrintATCRunner)
<arrsIncludedModules:{a|from <a> import *}; separator="\n">


def asn1scc_run_generated_testsuite(output: TestOutput) -> int:
    totalErrors: int = 0
    <arrsVars; separator="\n">


    output.report_suite_begin()

    # test_cases_python.stg:282
    <arrsTestFunctions;separator="\n">

    output.report_suite_end()

    if totalErrors > 0:
        output.report_tests_failed(<arrsTestFunctions.Length>, totalErrors)
        return 1
    else:
        output.report_all_tests_passed(<arrsTestFunctions.Length>)
        return 0
>>



invokeTestCaseAsFunc(sFuncName) ::= <<
# test_cases_python.stg:301
totalErrors += <sFuncName>(output)
>>


emitTestCaseAsFunc_h(sFuncName) ::= <<
>>

emitTestCaseAsFunc_dummy_init(sTypeName, sFuncName, sDummyVarname) ::= <<
# test_cases_python.stg:310
<sDummyVarname>: <sTypeName> = <sFuncName>()
>>

emitTestCaseAsFunc_dummy_init_function(sTypeName, sFuncName, sDummyVarname) ::= <<
# test_cases_python.stg:315
<sDummyVarname>: <sTypeName> = <sFuncName>()
>>

emitTestCaseAsFunc(sFuncName, arrsVars, sModName, sTasName, sAmber, sEnc, bValueAssignment, sInitializeTcData, bStatic, sGenerateDatFile, arrsDummyInitStatementsNeededForStatementCoverage, sInitAmber) ::= <<
# test_cases_python.stg:320
def <sFuncName>() -> None:    
    <arrsVars; separator="\n">

    <sInitializeTcData>

    result = <sTasName>_<sEnc>enc_dec(tc_data, "<sFuncName>")

    <sGenerateDatFile>
>>


printTestCaseFileDef(sThisFile, arrsIncludedModules, arrsTestFunctionDefs) ::= <<>>


printTestCaseFileBody(sThisFile, arrsIncludedModules, arrsTestFunctionBodies) ::= <<
# Code automatically generated by asn1scc tool (stg macro : printTestCaseFileBody)
from typing import Optional

import time

from asn1pylib import Asn1SccError
<arrsIncludedModules:{aim|from asn1pylib.asn1src.<aim> import *}; separator="\n">

<arrsTestFunctionBodies;separator="\n\n">

>>
