group uper_python;

rtlModuleName() ::= ""

call_base_type_func_encode(p, sFuncName) ::= <<
# uper_python.stg 6
result = <p>.encode(codec, check_constraints)
if not result:
    return result
>>
call_base_type_func_decode(p, sFuncName) ::= <<
# uper_python.stg 13
<p> = <sFuncName>(codec, check_constraints)
>>

/*******************************************************/
/*   U P E R                                           */
/*******************************************************/

EmitTypeAssignment_def_err_code(sErrCode, nErrValue) ::= <<
    # uper_python.stg 26
    <sErrCode>: ErrorCode = <nErrValue>
    # TODO: Remove old Scala Code (uper_python.stg):
    # @inline @cCode.inline val <sErrCode>: ErrorCode = <nErrValue>
>>

EmitTypeAssignment_def_encode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInPER, nMaxBitsInPER, soSparkAnnotations, bReqBytesForEncodingIsZero) ::= <<
# uper_python.stg 33
<arrsErrcodes:{x|<x>}; separator="\n">
<sTypeDefName>_REQUIRED_BYTES_FOR_ENCODING: int = <nMaxBytesInPER>
<sTypeDefName>_REQUIRED_BITS_FOR_ENCODING: int = <nMaxBitsInPER>
>>

EmitTypeAssignment_encode(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitialExp, bReqBytesForEncodingIsZero, bBsIsUnreferenced, bVarNameIsUnreferenced, soInitFuncName, arrsAnnots, arrsPrecond, soPostcond) ::= <<
# uper_python.stg 40

def <sFuncName>(<sVarName>: <sTypeDefName>, codec: UPER, check_constraints: bool = True):
    <arrsPrecond:{pre|require(<pre>)}; separator="\n">
    <arrsLocalVariables:{lv|<lv>}; separator="\n">
    <if(soIValidFuncName)>
    if check_constraints:
        res = <sVarName>.<soIValidFuncName>()
        if not res:
            # uper_python.stg 49
            return res
    # @ghost val oldCdc = snapshot(codec)
    <sContent>
    <else>
    <sContent>
    <endif>
    # uper_python.stg 56
    return 0
>>

EmitTypeAssignment_def_decode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInPER, nMaxBitsInPER, soSparkAnnotations, bReqBytesForEncodingIsZero) ::= <<
# uper_python.stg 61
<arrsErrcodes:{x|<x>}; separator="\n">
>>

EmitTypeAssignment_decode(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitialExp, bReqBytesForEncodingIsZero, bBsIsUnreferenced, bVarNameIsUnreferenced, soInitFuncName, arrsAnnots, arrsPrecond, soPostcond) ::= <<
def <sFuncName>(codec: UPER, check_constraints: bool = True): Union[<sTypeDefName>, Asn1SccError]: # uper:58
    <arrsPrecond:{pre|require(<pre>)}; separator="\n">
    <arrsLocalVariables:{lv|<lv>}; separator="\n">

    # @ghost val oldCdc = snapshot(codec)
    <sContent>

    <if(soIValidFuncName)>
    if check_constraints:
        res = <sVarName>.<soIValidFuncName>()
        if not res:
            # uper_python.stg 75
            return res
    <endif>
    return <sVarName>

# @ghost @pure <arrsAnnots:{ann|@<ann>}; separator=" ">
def <sFuncName>_pure(codec: UPER, check_constraints: bool = True): (UPER, Union[<sTypeDefName>, Asn1SccError]):
    <arrsPrecond:{pre|require(<pre>)}; separator="\n">
    cpy = codec.copy()
    res = <sFuncName>(cpy, check_constraints)
    # uper_python.stg 90
    return cpy, res
>>

InternalItem_oct_str_encode(p, sAcc, i, sErrCode) ::=<<
# uper_python.stg 95
if not codec.base.bitStream.appendByte(<p><sAcc>arr(<i>)):
    print("appendByte failed: not enough space for 1 byte")
>>

InternalItem_oct_str_decode(p, sAcc, i, sErrCode) ::=<<
# uper_python.stg 101
if not codec.read_byte(<p><sAcc>arr(<i>)):
    # uper_python.stg 103
    return Asn1SccError(<sErrCode>)
>>

PrintAlphabet2(arrnCharSet) /*nogen*/::= <<
# uper_python.stg 108
allowedCharSet: List[Byte] = list(<arrnCharSet:{ch|0x<ch;format="X2">}; wrap, anchor, separator=",">)
>>

InternalItem_string_with_alpha_encode(p, sErrCode, td/*:FE_StringTypeDefinition*/, i, nLastItemIndex, arrnAlphabetAsciiCodes, nAlphabetLength, nCharIndexSize) ::=<<
# uper_python.stg 113
<PrintAlphabet2(arrnAlphabetAsciiCodes)>
charIndex: int = GetCharIndex(<p>(<i>), allowedCharSet)
codec.base.encodeConstrainedWholeNumber(charIndex, 0, <nLastItemIndex>)
>>

InternalItem_string_with_alpha_decode(p, sErrCode,  td/*:FE_StringTypeDefinition*/, i, nLastItemIndex, arrnAlphabetAsciiCodes, nAlphabetLength, nCharIndexSize) ::=<<
# uper_python.stg 120
<PrintAlphabet2(arrnAlphabetAsciiCodes)>
<p>_arr_<i>_ = allowedCharSet(int(codec.base.decodeConstrainedWholeNumber(0, <nLastItemIndex>)))
>>

InternalItem_string_no_alpha_encode(p, sErrCode, i) ::=<<
# uper_python.stg 126
codec.base.encodeConstrainedWholeNumber(<p>(<i>), 0, 127)
>>

InternalItem_string_no_alpha_decode(p, sErrCode, i) ::=<<
# uper_python.stg 131
<p>_arr_<i>_ = codec.base.decodeConstrainedWholeNumberByte(0, 127) # uper:109
>>

/* INTEGER START*/

/*case: A:: = INTEGER (-5..20) */
IntFullyConstraint_encode(p, nMin, nMax, nBits, sSsuffix, sErrCode) ::= <<
# uper_python.stg 139
codec.base.encodeConstrainedWholeNumber(<p>, <nMin>, <nMax>)
>>

IntFullyConstraint_decode(p, nMin, nMax, nBits, sSsuffix, sErrCode) ::= <<
# uper_python.stg 144
<p> = codec.base.decodeConstrainedWholeNumber<sSsuffix>(<nMin>, <nMax>) # uper:122
>>

/*case: Positive fully constraint A:: = INTEGER (5..20) */
IntFullyConstraintPos_encode(p, nMin, nMax, nBits, sSsuffix, sErrCode, soRangeAssert) ::= <<
# uper_python.stg 150
<soRangeAssert>
codec.base.encodeConstrainedPosWholeNumber(<p>, <nMin>, <nMax>)
>>

IntFullyConstraintPos_decode(p, nMin, nMax, nBits, sSsuffix, sErrCode, soRangeAssert) ::= <<
# uper_python.stg 156
<p> = codec.base.decodeConstrainedPosWholeNumber<sSsuffix>(<nMin>, <nMax>) # uper:135
>>

/*case: A :: = INTEGER */
IntUnconstrained_encode(p, sErrCode, bCoverageIgnore) ::= "codec.base.encodeUnconstrainedWholeNumber(<p>)"
IntUnconstrained_decode(p, sErrCode, bCoverageIgnore) ::= << 
# uper_python.stg 163
res = codec.base.decodeUnconstrainedWholeNumber()
if res is None:
    # uper_python.stg 166
    return Asn1SccError(<sErrCode>)
elif:
 <p> = res
>>

/*case: A :: = INTEGER(MIN..5) */
IntUnconstrainedMax_encode(p, nMax, soCheckExp, sErrCode) ::= "codec.base.encodeUnconstrainedWholeNumber(<p>)"
IntUnconstrainedMax_decode(p, nMax, soCheckExp, sErrCode) ::= <<
# uper_python.stg 175
if !codec.base.decodeUnconstrainedWholeNumber() then # TODO meth does not return a boolean value...?
    <if(soCheckExp)>
    if not <soCheckExp>: 
        # uper_python.stg 179
        return Asn1SccError(<sErrCode>)
    <else>
    # uper_python.stg 182
    return Asn1SccError(<sErrCode>)
    <endif>
>>

/*case: A:: = INTEGER (-5..MAX) */
IntSemiConstraint_encode(p, nMin, sErrCode) ::= "codec.base.encodeSemiConstrainedWholeNumber(<p>, <nMin>)"
IntSemiConstraint_decode(p, nMin, sErrCode) ::= <<
# uper_python.stg 190
if not codec.base.decodeSemiConstrainedWholeNumber(<nMin>):
    # uper_python.stg 192
    return Asn1SccError(<sErrCode>)
>>

/*case: A:: = INTEGER (5..MAX) */
IntSemiConstraintPos_encode(p, nMin, sErrCode) ::= "codec.base.encodeSemiConstrainedPosWholeNumber(<p>, <nMin>)"
IntSemiConstraintPos_decode(p, nMin, sErrCode) ::= <<
# uper_python.stg 199
if not codec.base.decodeSemiConstrainedPosWholeNumber(<nMin>):
    # uper_python.stg 201
    return Asn1SccError(<sErrCode>)
>>

/*case: A:: = INTEGER (5..5) */
IntNoneRequired_encode(p, sConst, sErrCode) ::=<<
# uper_python.stg 207
# No need to encode the val <p>, it will always be <sConst> 
# NOPs
>>
IntNoneRequired_decode(p, sConst, sErrCode) ::= <<
# uper_python.stg 212
<p> = <sConst>
>>

/*case: A:: = INTEGER (5..40,...) */
IntRootExt_encode(p, nMin, sRootBaseConstraint, sIntBody, sErrCode) ::=<<
# uper_python.stg 218
codec.base.appendBitZero() # write extension bit
<sIntBody>
>>

IntRootExt_decode(p, nMin, sRootBaseConstraint, sIntBody, sErrCode) ::=<<
# uper_python.stg 224
extBit: Ref[Boolean] = Ref(false)

# read extension bit
success = codec.base.bitStream.readBit(extBit)
if success:
    if not extBit: # ext bit is zero ==> value is expected with root range
        <sIntBody>
    else
        <IntUnconstrained_decode(p=p, sErrCode = sErrCode, bCoverageIgnore="True")>
else
    ret = <sErrCode>
>>

/*case: A:: = INTEGER (5..40,..., 60..70) */
IntRootExt2_encode(p, nMin, sRootBaseConstraint, sIntBody, sErrCode) ::=<<
# uper_python.stg 240
if <sRootBaseConstraint>:
    codec.base.appendBitZero() # write extension bit, value within root range, so ext bit is zero
    <sIntBody>
else:
    # value is not within root range, so ext bit is one and value is encoded as unconstrained
    codec.base.appendBitOne()
    <IntUnconstrained_encode(p=p, sErrCode=sErrCode)>
>>

IntRootExt2_decode(p, nMin, sRootBaseConstraint, sIntBody, sErrCode) ::="<IntRootExt_decode(p=p, nMin=nMin, sRootBaseConstraint=sRootBaseConstraint, sIntBody=sIntBody, sErrCode=sErrCode)>"


/* INTEGER END*/

Boolean_encode(p, sErrCode) ::= <<
# uper_python.stg 256
codec.base.bitStream.appendBit(<p>)
>>

Boolean_decode(p, sErrCode) ::= <<
# uper_python.stg 261
<p> = codec.base.bitStream.readBit() # uper:225
>>

Real_encode(p, sSuffix, sErrCode) ::= "codec.base.encodeReal(<p>)"
Real_decode(p, sSuffix, sErrCode) ::= <<
# uper_python.stg 267
<p> = double(codec.base.decodeReal<sSuffix>()) # uper:234
>>

ObjectIdentifier_encode(p, sErrCode) ::= "codec.ObjectIdentifier_encode(<p>);"
ObjectIdentifier_decode(p, sErrCode) ::= <<
# uper_python.stg 273
if not codec.ObjectIdentifier_decode(): # uper:234 TODO
    # uper_python.stg 275
    return Asn1SccError(<sErrCode>)
>>

RelativeOID_encode(p, sErrCode) ::= "codec.RelativeOID_encode(<p>);"
RelativeOID_decode(p, sErrCode) ::= <<
# uper_python.stg 281
if not codec.RelativeOID_decode():
    # uper_python.stg 283
    return Asn1SccError(<sErrCode>)
>>

Time_encode(p, sTimeSubType, sErrCode) ::= "codec.<sTimeSubType>_encode(<p>);"
Time_decode(p, sTimeSubType, sErrCode) ::= <<
# uper_python.stg 289
if not codec.<sTimeSubType>_decode():
    # uper_python.stg 291
    return Asn1SccError(<sErrCode>)
>>

Enumerated_item_encode(p, sName, nIndex, nLastItemIndex) ::= <<
# uper_python.stg 296
case <sName>:
    codec.base.encodeConstrainedWholeNumber(<nIndex>, 0, <nLastItemIndex>)
>>
Enumerated_item_decode(p, sName, nIndex, nLastItemIndex) ::= <<
# uper_python.stg 301
case <nIndex>: <sName>
>>

Enumerated_encode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, nMin, nMax, nBits, sErrCode, nLastItemIndex, sFirstItemName) ::= <<
# uper_python.stg 306
match <p>: # uper:270
    <arrsItem; separator="\n">
>>

Enumerated_decode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, nMin, nMax, nBits, sErrCode, nLastItemIndex, sFirstItemName) ::= <<
# uper_python.stg 312
# TODO: <p> = ?????
match codec.base.decodeConstrainedWholeNumber(0, <nLastItemIndex>): # uper:277
    <arrsItem; separator="\n">
    case _:
        # uper_python.stg 317
        return Asn1SccError(<sErrCode>)
>>

Enumerated_no_switch_encode(p, td/*:FE_EnumeratedTypeDefinition*/, sErrCode, sEnumIndex, nLastItemIndex, sFirstItemName) ::= <<
# uper_python.stg 322
>>

Enumerated_no_switch_decode(p, td/*:FE_EnumeratedTypeDefinition*/, sErrCode, sEnumIndex, nLastItemIndex, sFirstItemName) ::= <<
# uper_python.stg 326
>>


/* CHOICE START*/

choice_child_encode(p, sAcc, sChildID, nChildIndex, nIndexSizeInBits, nLastItemIndex, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr, bIsSequence, bIsEnum) ::= <<
# uper_python.stg 333
case <sChildID>(<sChildName>):
    codec.base.encodeConstrainedWholeNumber(<nChildIndex>, 0, <nLastItemIndex>)
    <sChildContent>
>>

choice_child_decode(p, sAcc, sChildID, nChildIndex, nIndexSizeInBits, nLastItemIndex, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr, bIsSequence, bIsEnum) ::= <<
# uper_python.stg 340
case <nChildIndex>:
    <sChildContent>
    <sChildID>(<sChildName>)
>>

choice_encode(p, sAcc, arrsChildren, nLastItemIndex, sChoiceIndexName, sErrCode, td/*:FE_ChoiceTypeDefinition*/, nIndexSizeInBits, bIntroSnap) ::= <<
# uper_python.stg 347
<if(bIntroSnap)>
# @ghost val codec_0_1 = snapshot(codec)
<endif>

match <p>: # uper:310
    <arrsChildren: {ch|<ch>}; separator="\n">
>>

choice_decode(p, sAcc, arrsChildren, nLastItemIndex, sChoiceIndexName, sErrCode, td/*:FE_ChoiceTypeDefinition*/, nIndexSizeInBits, bIntroSnap) ::= <<
# uper_python.stg 357
<if(bIntroSnap)>
# @ghost val codec_0_1 = snapshot(codec)
<endif>

# TODO: <p> = ????
match codec.base.decodeConstrainedWholeNumber(0, <nLastItemIndex>): # uper:317
    <arrsChildren: {ch|<ch>}; separator="\n">
    case _:
        # uper_python.stg 366
        return Asn1SccError(<sErrCode>)
>>

/* CHOICE END*/

/* SEQUENCE START */
sequence_presence_bit_encode(p, sAcc, sChName, soExistVar, sErrCode) ::= <<
# uper_python.stg 374
codec.base.bitStream.appendBit(<p><sAcc><sChName>.isDefined)
>>
sequence_presence_bit_decode(p, sAcc, sChName, soExistVar, sErrCode) ::= <<
# uper_python.stg 378
<soExistVar> = codec.base.bitStream.readBit()
>>

sequence_presence_bit_fix_encode(p, sAcc, sChName, soExistVar, sErrCode, sVal) ::= <<
# uper_python.stg 383
codec.base.bitStream.appendBit(<sVal>)
>>

sequence_presence_bit_fix_decode(p, sAcc, sChName, soExistVar, sErrCode, sVal) ::= <<
# uper_python.stg 388
<sequence_presence_bit_decode(p=p, sAcc=sAcc, sChName=sChName, soExistVar=soExistVar, sErrCode=sErrCode)>
>>

sequence_mandatory_child_encode(sChName, sChildContent) ::= <<
# uper_python.stg 393
# Encode <sChName> sequence_mandatory_child_encode
<sChildContent>
>>

sequence_mandatory_child_decode(sChName, sChildContent) ::= <<
# uper_python.stg 399
# Decode <sChName> sequence_mandatory_child_decode
<sChildContent>

>>

sequence_optional_child_encode(p, sAcc, sChName, sChildContent, soExistVar, soChildExpr, sChildTypedef) ::= <<
# uper_python.stg 406
# Encode <sChName>
match <p><sAcc><sChName>:
    case SomeMut(<sChName>):
        <sChildContent>
>>

sequence_optional_child_decode(p, sAcc, sChName, sChildContent, soExistVar, soChildExpr, sChildTypedef) ::= <<
# uper_python.stg 414
# Decode <sChName>
if <soExistVar>:
    <sChildContent>
    <p>_<sChName> = SomeMut(<soChildExpr>)
else:
    <p>_<sChName> = NoneMut[<sChildTypedef>]()
>>


sequence_default_child_encode(p, sAcc, sChName, sChildContent, soExistVar, soChildExpr, sChildTypedef, sInitWithDefaultValue) ::= <<
# uper_python.stg 425
<sequence_optional_child_encode(p=p, sAcc=sAcc, sChName=sChName, soExistVar=soExistVar, soChildExpr=soChildExpr, sChildTypedef=sChildTypedef, sChildContent=sChildContent)>
>>


sequence_default_child_decode(p, sAcc, sChName, sChildContent, soExistVar, soChildExpr, sChildTypedef, sInitWithDefaultValue) ::= <<
# uper_python.stg 431
# Decode <sChName>
if <soExistVar>:
    <sChildContent>
    <p>_<sChName> = SomeMut(<soChildExpr>)
else:
    <p>_<sChName> = <sInitWithDefaultValue>
>>

sequence_build(p, sTypeDefName, bIsOptional, arrsChildren) ::= <<
# uper_python.stg 441
<p> = cls(<arrsChildren; separator=", ">)
>>


/* SEQUENCE END */

loopFixedItem (i, fixedSize,  sInternalItem)::= /*nogen*/<<
# uper_python.stg 453
<i>: int = 0
while <i> \< int(<fixedSize>):
    <sInternalItem>
    <i> += 1
>>


/* IA5String & Numeric String */

str_FixedSize_encode(p, sTasName, i, sInternalItem, nFixedSize, nIntItemMinSize, nIntItemMaxSize, nAlignSize, soInitExpr, bIntroSnap, soCallAux) ::= <<
# uper_python.stg 464
<if(bIntroSnap)>
# @ghost val codec_0_1 = snapshot(codec)
<endif>

<soCallAux>
>>

str_FixedSize_decode(p, sTasName, i, sInternalItem, nFixedSize, nIntItemMinSize, nIntItemMaxSize, nAlignSize, soInitExpr, bIntroSnap, soCallAux) ::= <<
# uper_python.stg 473
<if(bIntroSnap)>
# @ghost val codec_0_1 = snapshot(codec)
<endif>

<soCallAux>
>>


str_VarSize_encode(p, sPIden, sTasName, i, sInternalItem, nSizeMin, nSizeMax, nSizeInBits, nIntItemMinSize, nIntItemMaxSize, nAlignSize, soInitExpr, soCallAux) ::= <<
# uper_python.stg 483
nStringLength: int = len(<p>)
# ret = nStringLength >= <nSizeMin> && nStringLength \<= <nSizeMax>;
codec.encode_constrained_whole_number(nStringLength, <nSizeMin>, <nSizeMax>)
<sPIden>_nCount: int = nStringLength
<soCallAux>
>>

str_VarSize_decode(p, sPIden, sTasName, i, sInternalItem, nSizeMin, nSizeMax, nSizeInBits, nIntItemMinSize, nIntItemMaxSize, nAlignSize, soInitExpr, soCallAux) ::= <<
# uper_python.stg 492
nStringLength: int = codec.decode_constrained_whole_number(<nSizeMin>, <nSizeMax>)
<p>_nCount = nStringLength
<soCallAux>
>>

/* SEQUENCE OF & OCTET STRING*/
seqOf_FixedSize_encode(p, sTasName, i, sInternalItem, nFixedSize, nIntItemMinSize, nIntItemMaxSize, nAlignSize, sChildInitExpr, soCallAux) ::= <<
# uper_python.stg 500
<soCallAux>
>>

seqOf_FixedSize_decode(p, sTasName, i, sInternalItem, nFixedSize, nIntItemMinSize, nIntItemMaxSize, nAlignSize, sChildInitExpr, soCallAux) ::= <<
# uper_python.stg 505
<soCallAux>
>>

seqOf_VarSize_encode(p, sAcc, sTasName, i, sInternalItem, nSizeMin, nSizeMax, nSizeInBits, nIntItemMinSize, nIntItemMaxSize, nAlignSize, sChildInitExpr, sErrCode, nAbsOffset, nRemainingMinBits, nLevel, nIx, nOffset, bIntroSnap, soCallAux) ::= <<
# uper_python.stg 510
<if(bIntroSnap)>
# @ghost val codec_0_1 = snapshot(codec)
<endif>

codec.encode_constrained_whole_number(<p><sAcc>nCount, <nSizeMin>, <nSizeMax>)
<soCallAux>
>>

seqOf_VarSize_decode(p, sAcc, sTasName, i, sInternalItem, nSizeMin, nSizeMax, nSizeInBits, nIntItemMinSize, nIntItemMaxSize, nAlignSize, sChildInitExpr, sErrCode, nAbsOffset, nRemainingMinBits, nLevel, nIx, nOffset, bIntroSnap, soCallAux) ::= <<
# uper_python.stg 520
<if(bIntroSnap)>
# @ghost val codec_0_1 = snapshot(codec)
<endif>

<p>_nCount = int(codec.decode_constrained_whole_number(<nSizeMin>, <nSizeMax>))

<soCallAux>
>>

octet_FixedSize_encode(sTypeDefName, p, sAcc, nFixedSize) ::= <<
# uper_python.stg 531
codec.encode_octet_string_no_length_vec(<p><sAcc>arr, int(<nFixedSize>))
>>

octet_FixedSize_decode(sTypeDefName, p, sAcc, nFixedSize) ::= <<
# uper_python.stg 536
<p> = <sTypeDefName>(codec.decode_octet_string_no_length_vec(<nFixedSize>))
>>

octet_VarSize_encode(sTypeDefName, p, sAcc, nSizeMin, nSizeMax, nSizeInBits, sErrCode) ::= <<
# uper_python.stg 541
codec.encode_constrained_whole_number(<p><sAcc>nCount, <nSizeMin>, <nSizeMax>)
codec.encode_octet_string_no_length_vec(<p><sAcc>arr, int(<p><sAcc>nCount))
>>

octet_VarSize_decode(sTypeDefName, p, sAcc, nSizeMin, nSizeMax, nSizeInBits, sErrCode) ::= <<
# uper_python.stg 547
# decode length
<p>_nCount = codec.decode_constrained_whole_number(<nSizeMin>, <nSizeMax>)
# decode payload
<p>_arr = codec.decode_octet_string_no_length_vec(int(<p>_nCount))
<p> = <sTypeDefName>(<p>_nCount, <p>_arr)
>>

/* BIT STRING*/
bitString_FixSize_encode(sTypeDefName, p, sAcc, nFixedSize, sErrCode) ::= <<
# uper_python.stg 557
assert(int(<nFixedSize>) >= 0) # overflow may happen during cast
codec.bitStream.appendBitsMSBFirstVec(<p><sAcc>arr, int(<nFixedSize>))

>>
bitString_FixSize_decode(sTypeDefName, p, sAcc, nFixedSize, sErrCode) ::= <<
# uper_python.stg 563
<p> = <sTypeDefName>(codec.bitStream.readBitsVec(int(<nFixedSize>)))
>>

bitString_VarSize_encode(sTypeDefName, p, sAcc, nSizeMin, nSizeMax, sErrCode, nSizeInBits) ::= <<
# uper_python.stg 568
codec.encode_constrained_whole_number(<p><sAcc>nCount, <nSizeMin>, <nSizeMax>)
<bitString_FixSize_encode(sTypeDefName=sTypeDefName, p=p, sAcc=sAcc, nFixedSize=[p, sAcc,"nCount"], sErrCode=sErrCode)>
>>

bitString_VarSize_decode(sTypeDefName, p, sAcc, nSizeMin, nSizeMax, sErrCode, nSizeInBits) ::= <<
# uper_python.stg 574
<p>_nCount = codec.decode_constrained_whole_number(<nSizeMin>, <nSizeMax>)
<p>_arr = codec.bitStream.readBitsVec(int(<p>_nCount))
<p> = <sTypeDefName>(<p>_nCount, <p>_arr)
>>


FixedSize_Fragmentation_sqf_64K_encode(p, sAcc,sCurOffset, sCurBlockSize, sBlockIndex, nBlocks64K, sInternalItem, sBLI, sRemainingItemsVar, bIsBitStringType, sErrCodeName) ::=<<
# uper_python.stg 582
# encode <nBlocks64K> x 64K Blocks
<sCurBlockSize> = 0x10000;
<sCurOffset>: int = 0;
<sBlockIndex>: int = 0
while <sBlockIndex> \< <nBlocks64K>:
    codec.encode_constrained_whole_number(0xC4, 0, 0xFF)
    <if(bIsBitStringType)>
    codec.bitStream.appendBitsMSBFirst(<p><sAcc>arr[<sCurOffset>/8], int(<sCurBlockSize>))

    <else>
    <sBLI> = int(<sCurOffset>)
    while <sBLI> \< int(<sCurBlockSize> + <sCurOffset>):
        <sInternalItem>
        <sBLI> += 1
    <endif>
    <sCurOffset> += <sCurBlockSize>
    <sBlockIndex> += 1

>>

FixedSize_Fragmentation_sqf_small_block_encode(p, sAcc,sInternalItem, nBlockSize, sBlockId, sCurOffset, sCurBlockSize, sBLI, sRemainingItemsVar, bIsBitStringType, sErrCodeName) ::=<<
# uper_python.stg 604
# encode <nBlockSize> Block
<sCurBlockSize> = <nBlockSize>
codec.encode_constrained_whole_number(<sBlockId>, 0, 0xFF)
<if(bIsBitStringType)>
codec.bitStream.appendBitsMSBFirst(<p><sAcc>arr[<sCurOffset>/8], int(<sCurBlockSize>))
<else>
for <sBLI> in range(int(<sCurOffset>), int(<sCurBlockSize> + <sCurOffset>)):
    <sInternalItem>
<endif>
<sCurOffset> += <sCurBlockSize>
>>

FixedSize_Fragmentation_sqf_remaining_encode(p, sAcc,sInternalItem, bRemainingItemsWithinByte, nRemainingItemsVar, sCurOffset, sBLI, sRemainingItemsVar, bIsBitStringType, sErrCodeName) ::= <<
# uper_python.stg 618
# encode remaining <nRemainingItemsVar> items
<if(bRemainingItemsWithinByte)>
codec.encode_constrained_whole_number(<nRemainingItemsVar>, 0, 0xFF)
<else>
codec.appendBitOne()
codec.encode_constrained_whole_number(<nRemainingItemsVar>, 0, 0x7FFF)
<endif>
<if(bIsBitStringType)>
codec.bitStream.appendBitsMSBFirst(<p><sAcc>arr[<sCurOffset>/8], int(<nRemainingItemsVar>))
<else>
for <sBLI> in range(int(<sCurOffset>), int(<sCurOffset> + <nRemainingItemsVar>)):
    <sInternalItem>

<endif>
>>

FixedSize_Fragmentation_sqf_encode(p, sAcc, arrsEncodingParts, nFixedSize, bIsBitStringType) ::= <<
# uper_python.stg 636
<arrsEncodingParts; separator="\n">
>>

Fragmentation_sqf_encode(p, sAcc, sInternalItem, nIntItemMaxSize, nSizeMin, nSizeMax, nRequiredBitsForUPerEncoding, bIsVariableSize, sErrCodeName, sRemainingItemsVar, sCurBlockSize, sBlockIndex, sCurOffset, sBLJ, sBLI, sLengthTmp, bIsBitStringType, bIsAsciiString) ::= <<
# uper_python.stg 641
<sRemainingItemsVar> = <if(bIsAsciiString)>(asn1SccSint)strlen(<p>)<else><if(bIsVariableSize)><p><sAcc>nCount<else><nSizeMax><endif><endif>
<sCurBlockSize>: int = 0
<sCurOffset>: int = 0
<sBlockIndex>: int = 0
while <sRemainingItemsVar> >= 0x4000 && <sBlockIndex> \< <if(bIsAsciiString)>(asn1SccSint)strlen(<p>)<else><if(bIsVariableSize)><p><sAcc>nCount<else><nSizeMax><endif><endif>:
    if <sRemainingItemsVar> >= 0x10000:
        <sCurBlockSize> = 0x10000
        codec.encode_constrained_whole_number(0xC4, 0, 0xFF)
    elif <sRemainingItemsVar> >= 0xC000:
        <sCurBlockSize> = 0xC000
        codec.encode_constrained_whole_number(0xC3, 0, 0xFF)
    elif <sRemainingItemsVar> >= 0x8000:
        <sCurBlockSize> = 0x8000
        codec.encode_constrained_whole_number(0xC2, 0, 0xFF)
    else:
        <sCurBlockSize> = 0x4000
        codec.encode_constrained_whole_number(0xC1, 0, 0xFF)

    <if(bIsBitStringType)>
    codec.bitStream.appendBitsMSBFirst(<p><sAcc>arr[<sCurOffset>/8], int(<sCurBlockSize>))
    <else>
    <sBLI>=int(<sCurOffset>)
    while <sBLI> \< int(<sCurBlockSize> + <sCurOffset>)
    {
        <sInternalItem>
        <sBLI> += 1
    }
    <endif>
    <sCurOffset> += <sCurBlockSize>
    <sRemainingItemsVar> -= <sCurBlockSize>
    <sBlockIndex> = <sBlockIndex> + 1

if <sRemainingItemsVar> \<= 0x7F:
    codec.encode_constrained_whole_number(<sRemainingItemsVar>, 0, 0xFF)
else:
    codec.appendBitOne()
    codec.encode_constrained_whole_number(<sRemainingItemsVar>, 0, 0x7FFF)

<if(bIsBitStringType)>
codec.bitStream.appendBitsMSBFirst(<p><sAcc>arr[<sCurOffset>/8], int(<sRemainingItemsVar>))
<else>
<sBLI> = int(<sCurOffset>)
while <sBLI> \< int(<sCurOffset> + <sRemainingItemsVar>):
{
    <sInternalItem>
    <sBLI> += 1
}
<endif>
>>


FixedSize_Fragmentation_sqf_64K_decode(p, sAcc,sCurOffset, sCurBlockSize, sBlockIndex, nBlocks64K, sInternalItem, sBLI, sRemainingItemsVar, bIsBitStringType, sErrCodeName) ::=<<
# uper_python.stg 694
# we expect to decode <nBlocks64K> Blocks and each block must contain 64K elements. Each block must begin with the byte 0xC4
<sCurBlockSize> = 0x10000
<sCurOffset>: int = 0
*pErrCode = <sErrCodeName> # TODO: no pointers in python...

for <sBlockIndex> in range(0, nBlocks64K>):        
    ret: int = codec.decode_constrained_whole_number(<sRemainingItemsVar>, 0, 0xFF)
    check = (ret == 0) && (<sRemainingItemsVar> == 0xC4);
    ret = 0 if check else Asn1SccError(<sErrCodeName>)
    if ret == 0:
        <if(bIsBitStringType)>
        ret = int(codec.bitStream.readBits(&<p><sAcc>arr[<sCurOffset>/8], <sCurBlockSize>))
        ret = 0 if ret == 0 else <sErrCodeName>;

        <else>
        <sBLI> = int(<sCurOffset>)
        while <sBLI> \< int(<sCurBlockSize> + <sCurOffset>):
            <sInternalItem>
            <sBLI> += 1

        <endif>
        <sCurOffset> += <sCurBlockSize>;

    if not ret:
        break
>>


FixedSize_Fragmentation_sqf_small_block_decode(p, sAcc,sInternalItem, nBlockSize, sBlockId, sCurOffset, sCurBlockSize, sBLI, sRemainingItemsVar, bIsBitStringType, sErrCodeName) ::=<<
# uper_python.stg 724
# decode a single Block with <nBlockSize> items
<sCurBlockSize> = <nBlockSize>;
ret = codec.decode_constrained_whole_number(<sRemainingItemsVar>, 0, 0xFF)
val check = (ret == 0) && (<sRemainingItemsVar> == <sBlockId>);
ret = if (check) then 0 else Asn1SccError(<sErrCodeName>)
if not isinstance(ret, Asn1SccError):
    <if(bIsBitStringType)>
        ret = codec.bitStream.readBits(&<p><sAcc>arr[<sCurOffset>/8], <sCurBlockSize>.toInt); # TODO call wrong
        ret = 0 if (ret == 0) else Asn1SccError(<sErrCodeName>)
    
    <else>
        <sBLI> = <sCurOffset>
        while <sBLI> \< (<sCurBlockSize> + <sCurOffset>):
            <sInternalItem>
            <sBLI> += 1
    <endif>
        <sCurOffset> += <sCurBlockSize>
>>

FixedSize_Fragmentation_sqf_remaining_decode(p, sAcc,sInternalItem, bRemainingItemsWithinByte, nRemainingItemsVar, sCurOffset, sBLI, sRemainingItemsVar, bIsBitStringType, sErrCodeName) ::= <<
# uper_python.stg 745
# decode remaining <nRemainingItemsVar> items
<if(bRemainingItemsWithinByte)>
ret = codec.decode_constrained_whole_number(<sRemainingItemsVar>, 0, 0xFF)
ret = ret and (<sRemainingItemsVar> == <nRemainingItemsVar>);

<else>
ret = codec.decode_constrained_whole_number(<sRemainingItemsVar>, 0, 0xFFFF)
ret = ret and ((0x8000 & <sRemainingItemsVar>) > 0) and ( (0x7FFF & <sRemainingItemsVar>) == <nRemainingItemsVar>);

<endif>
if ret == 0:
    <if(bIsBitStringType)>
    ret = codec.bitStream.readBits(&<p><sAcc>arr[<sCurOffset>/8], <nRemainingItemsVar>.toInt); # TODO call wrong
    ret = 0 if not isinstance(ret, Asn1SccError) else Asn1SccError(<sErrCodeName>)

    <else>
    <sBLI> = int(<sCurOffset>)
    while <sBLI> \< int(<sCurOffset> + <nRemainingItemsVar>):
        <sInternalItem>
        <sBLI> += 1

    <endif>
>>

FixedSize_Fragmentation_sqf_decode(p, sAcc, arrsEncodingParts, nFixedSize, bIsBitStringType) ::= <<
# uper_python.stg 771
<arrsEncodingParts; separator="\n">
<if(bIsBitStringType)>
<p>[<nFixedSize>] = 0x0
<endif>
>>


Fragmentation_sqf_decode(p, sAcc, sInternalItem, nIntItemMaxSize, nSizeMin, nSizeMax, nRequiredBitsForUPerEncoding, bIsVariableSize, sErrCodeName, sRemainingItemsVar, sCurBlockSize, sBlockIndex, sCurOffset, sBLJ, sBLI, sLengthTmp, bIsBitStringType, bIsAsciiString) ::= <<
# uper_python.stg 780
<sRemainingItemsVar>: int = 0
<sCurBlockSize>: int = 0
<sCurOffset>: int = 0
<if(bIsVariableSize)>
<sLengthTmp>: int = 0
<endif>

<sRemainingItemsVar> = int(codec.decode_constrained_whole_number(0, 0xFF)) # uper:733

while (<sRemainingItemsVar> & 0xC0) == 0xC0:
    if <sRemainingItemsVar> == 0xC4:
        <sCurBlockSize> = 0x10000
    elif <sRemainingItemsVar> == 0xC3:
        <sCurBlockSize> = 0xC000
    elif <sRemainingItemsVar> == 0xC2:
        <sCurBlockSize> = 0x8000
    elif <sRemainingItemsVar> == 0xC1:
        <sCurBlockSize> = 0x4000
    else:
        # uper_python.stg 800
        return Asn1SccError(<sErrCodeName>)

    if <sCurOffset> + <sCurBlockSize> > <nSizeMax>:
        # uper_python.stg 804
        return Asn1SccError(<sErrCodeName>)

    <if(bIsBitStringType)>
    if not codec.bitStream.readBits(&<p><sAcc>arr[<sCurOffset>/8], <sCurBlockSize>):
       # uper_python.stg 809
       return <sErrCodeName>
    <else>
    <sBLI> = <sCurOffset>
    while <sBLI> \< (<sCurOffset> + <sCurBlockSize>):
        <sInternalItem>
        <sBLI> += 1
    <endif>

    <if(bIsVariableSize)>
    <sLengthTmp> += <sCurBlockSize>
    <endif>
    <sCurOffset> += <sCurBlockSize>
    <sRemainingItemsVar> = int(codec.decode_constrained_whole_number(0, 0xFF)) # uper:770
}

if (<sRemainingItemsVar> & 0x80) > 0:
    len2: int = 0;
    <sRemainingItemsVar> \<\<= 8 # TODO: how to do this bit shifting in python?
    len2 = int(codec.decode_constrained_whole_number(0, 0xFF)) # uper:780

    <sRemainingItemsVar> |= len2;
    <sRemainingItemsVar> &= 0x7FFF;

if <sCurOffset> + <sRemainingItemsVar> \<= <nSizeMax>:
    # uper_python.stg 834
    return Asn1SccError(<sErrCodeName>)

<if(bIsBitStringType)>
if not codec.bitStream.readBits(<p><sAcc>arr[<sCurOffset>/8], int(<sRemainingItemsVar>))
    # uper_python.stg 839
    return <sErrCodeName>

<else>
<sBLI> = <sCurOffset>
while <sBLI> \< (<sCurOffset> + <sRemainingItemsVar>):
    <sInternalItem>
    <sBLI> += 1
<endif>

<if(bIsVariableSize)>
<sLengthTmp> += <sRemainingItemsVar>
<endif>

<if(bIsVariableSize)>
if (<sLengthTmp> >= <nSizeMin>) and (<sLengthTmp> \<= <nSizeMax>):
    <if(!bIsAsciiString)>
    <p><sAcc>nCount = <sLengthTmp>
    <else>
    <p>[<sLengthTmp>] = 0x0
    <endif>
else
    # uper_python.stg 861
    return Asn1SccError(<sErrCodeName>)

<else>

<if(bIsAsciiString)>
<p>[<nSizeMax>] = 0x0
<endif>

<endif>
>>

octet_string_containing_func_encode(p, sFuncName, sReqBytesForUperEncoding, nBits, nMinSize, nMaxSize) ::= <<
# uper_python.stg 874
# TODO: open new scope to declare some variables
    # encode to a temporary bitstream
    static byte arr[<sReqBytesForUperEncoding>]
    BitStream bitStrm
    BitStream_Init(&bitStrm, arr, sizeof(arr))

    ret = <sFuncName>(<p>, &bitStrm, false) # TODO call wrong
    if ret:
        nCount: int = bitStrm.currentByte if bitStrm.currentBit == 0 else (bitStrm.currentByte + 1)
        ret = pBitStrm.encodeOctetString(arr, nCount, <nMinSize>, <nMaxSize>)
>>

octet_string_containing_func_decode(p, sFuncName, sReqBytesForUperEncoding, nBits, nMinSize, nMaxSize) ::= <<
# uper_python.stg 888
# TODO: open new scope to declare some variables
# decode to a temporary bitstream
static byte arr[<sReqBytesForUperEncoding>]
BitStream bitStrm
BitStream_Init(&bitStrm, arr, sizeof(arr))
nCount: int = 0
ret = pBitStrm.decodeOctetString(arr, &nCount, <nMinSize>, <nMaxSize>);
if ret:
    ret = <sFuncName>(<p>, &bitStrm);
>>

bit_string_containing_func_encode(p, sFuncName, sReqBytesForUperEncoding, sReqBitsForUperEncoding, nBits, nMinSize, nMaxSize) ::= <<
# uper_python.stg 901
# open new scope to declare some variables
# encode to a temporary bitstream
static byte arr[<sReqBytesForUperEncoding>]
BitStream bitStrm
BitStream_Init(&bitStrm, arr, sizeof(arr))

ret = <sFuncName>(<p>, &bitStrm, false)
if ret:
    nCount: int = bitStrm.currentByte*8 + bitStrm.currentBit;
    ret = pBitStrm.encodeBitString(arr, nCount, <nMinSize>, <nMaxSize>);
>>

bit_string_containing_func_decode(p, sFuncName, sReqBytesForUperEncoding, sReqBitsForUperEncoding, nBits, nMinSize, nMaxSize) ::= <<
# uper_python.stg 915
# open new scope to declare some variables

#decode to a temporary bitstream*/
static byte arr[<sReqBytesForUperEncoding>];
BitStream bitStrm;
BitStream_Init(&bitStrm, arr, sizeof(arr));
nCount: int = 0
ret = pBitStrm.decodeBitString(arr, &nCount, <nMinSize>, <nMaxSize>);
if ret:
    ret = <sFuncName>(<p>, &bitStrm)

>>


sparkAnnotations_encode(sTypeDefName) ::= <<
# uper_python.stg 931
>>

sparkAnnotations_decode(sTypeDefName) ::= <<
# uper_python.stg 935
>>

Null_declare(p) ::= "<p>: NullType = NullType()"

decode_nullType(p) ::= <<
# uper_python.stg 941
# no encoding/decoding is required
>>

decode_empty_sequence_emptySeq(p) ::= <<
# uper_python.stg 946
# no encoding/decoding is required
>>

JoinItems(sPart, soNestedPart) ::= <<
# uper_python.stg 951
<sPart>
<if(soNestedPart)>
if ret:
    <soNestedPart>
<endif>
>>

update_array_item(p, sI, sExpr) ::= <<
# uper_python.stg 960
<p>.arr(<sI>) = freshCopy(<sExpr>) # TODO: FIXME: To get around aliasing restriction, ideally we should do things differently
>>

InternalItem_bit_str_encode(p, i, sErrCode) ::=<<
# uper_python.stg 965
>>

InternalItem_bit_str_decode(p, i, sErrCode) ::=<<
# uper_python.stg 969
>>