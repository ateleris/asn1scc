group header_python;

rtlModuleName() ::= ""

indentation(sStatement) ::=<<
    <sStatement>
>>

PrintSpecificationFile(sFileNameWithNoExtUpperCase, sPackageName, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrototypes, arrsUtilityDefines, bHasEncodings, bXer) ::= <<
"""
Code automatically generated by asn1scc tool
"""
from asn1python import *

<arrsTypeAssignments:{tas|<tas>}; separator="\n">

<arrsValueAssignments:{vas|<vas>}; separator="\n">

<arrsPrototypes:{proto|<proto>}; separator="\n">
>>

Define_TAS(sTypeDefinition, arrsProcs) ::= <<
<sTypeDefinition>

<arrsProcs; separator="\n\n">
>>

PrintValueAssignment(sName, sTypeDecl, sValue) ::= <<
# @inline @cCode.inline val <sName>: <sTypeDecl> = <sValue> # defined in body
>>

/*
Python TYPES
*/

Declare_Integer() ::="Int64" // TODO: is this really 64 bit? 
Declare_PosInteger() ::="UInt64" // TODO: is this really 64 bit?
Declare_IntegerNoRTL() ::="LongNoRTL" // TODO
Declare_PosIntegerNoRTL() ::="ULongNoRTL" // TODO

Declare_Boolean() ::= "Asn1Boolean"
Declare_Real() ::= "Asn1Real"

Declare_Int8() ::="Int8"
Declare_UInt8() ::="UInt8"
Declare_Int16() ::="Int16"
Declare_UInt16() ::="UInt16"
Declare_Int32() ::="Int32"
Declare_UInt32() ::="UInt32"
Declare_Int64() ::="Int64"
Declare_UInt64() ::="UInt64"

Declare_Real32() ::= "Asn1Real32"
Declare_Real64() ::= "Asn1Real64"

Declare_BooleanNoRTL() ::= "BooleanNoRTL"
Declare_RealNoRTL() ::= "RealNoRTL"


Declare_Null() ::= "NullType"
Declare_NullNoRTL() ::= "NullType"
Declare_ObjectIdentifier() ::= "Asn1ObjectIdentifier"
Declare_ObjectIdentifierNoRTL() ::= "Asn1ObjectIdentifier"

Declare_Asn1LocalTime                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTime                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZone     	()::= "Asn1LocalTimeWithTimeZone"
Declare_Asn1Date                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTime            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTime              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZone	()::= "Asn1DateLocalTimeWithTimeZone"

Declare_Asn1LocalTimeNoRTL                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTimeNoRTL                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZoneNoRTL     	()::= "Asn1LocalTimeWithTimeZone"
Declare_Asn1DateNoRTL                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTimeNoRTL            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTimeNoRTL              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZoneNoRTL	()::= "Asn1DateLocalTimeWithTimeZone"


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs, arrsAnnots) ::= <<
<arrsAnnots:{ann|@<ann>}; separator=" ">
type <sTypeDefinitionName> = <sParentType>
<soExtraDefs>
>>





/******************************************************************************************************************************/
/***********************************       NEW TYPE DEFINITIONS    ************************************************************/
/******************************************************************************************************************************/

/***********************************       ENUMERATED    ************************************************************/

Define_new_enumerated_item(td/*:FE_EnumeratedTypeDefinition*/, sName, nValue) ::= <<
from enum import Enum

class <td.typeName>(Enum):
    <sName> = <nValue>
    
    @property
    def i(self):
        return self.value
    
# TODO: Remove old Scala Code:
# case object <sName> extends <td.typeName>:
#     override def i: Int32 = <nValue>
>>

Define_new_enumerated_item_macro(td/*:FE_EnumeratedTypeDefinition*/, sAsn1Name, sCName) ::= <<
# type <sCName> = <td.typeName>.<sAsn1Name>
>>

Define_new_enumerated(td/*:FE_EnumeratedTypeDefinition*/, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax, arrsResolvingMacros) ::= <<
from enum import Enum

class <td.typeName>:
    i: Int32 = 0

object <td.typeName>:
    <arrsEnumNamesAndValues:{it|<it>}; separator="\n">

# please use the following macros to avoid breaking code.
<arrsResolvingMacros; separator="\n">


# TODO: Remove old Scala Code:
# sealed trait <td.typeName>:
#     def i: Int
# object <td.typeName>:
#     <arrsEnumNamesAndValues:{it|<it>}; separator="\n">
>>

Define_subType_enumerated(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, soParentTypePackage) ::= <<
type <prTd.typeName> <td.typeName>

# TODO: Remove old Scala Code:
# typedef <prTd.typeName> <td.typeName>
>>

Define_new_enumerated_private(td/*:FE_EnumeratedTypeDefinition*/, arrsValidEnumNames, arrsEnumNames) ::= <<
>>

Define_subType_enumerated_private(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, arrsValidEnumNames, arrsEnumNames) ::= <<
>>

/***********************************       STRING    ************************************************************/

Define_new_ia5string(td/*:FE_StringTypeDefinition*/, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
<td.typeName> = List[UInt8]

# TODO: Remove old Scala Code:
# type <td.typeName> = Vector[UByte]
>>

Define_subType_ia5string(td/*:FE_StringTypeDefinition*/, prTd/*:FE_StringTypeDefinition*/, soParentTypePackage) ::= <<
type <prTd.typeName> <td.typeName>

# TODO: Remove old Scala Code:
# typedef <prTd.typeName> <td.typeName>
>>

/***********************************       OCTET STRING    ************************************************************/

Define_new_octet_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, arrsInvariants) ::= <<
<if(!bFixedSize)>
# nCount equals to Number of bytes in the array. Max value is : <nMax> (unsure - TODO read asn1 standard)

<endif>
from dataclasses import dataclass

@dataclass(frozen=True)
class <td.typeName>:
    <if(!bFixedSize)>nCount: Int64 = 0 <endif>
    arr: List[UInt8] = []
    
    <arrsInvariants; separator="\n">
    
# TODO: Remove old Scala Code:
# case class <td.typeName>(<if(!bFixedSize)>nCount: Long, <endif>arr: Vector[UByte])
# {
#     <arrsInvariants; separator="\n">
# }
>>

Define_subType_octet_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
type <prTd.typeName> <td.typeName>

# TODO: Remove old Scala Code:
# typedef <prTd.typeName> <td.typeName>
>>

/***********************************       BIT STRING    ************************************************************/

Define_new_bit_string_named_bit(td/*:FE_SizeableTypeDefinition*/, sTargetLangBitName, sHexValue, sComment) ::= <<
# TODO: Unclear what to do here
#define <td.typeName>_<sTargetLangBitName> 0x<sHexValue>  /*<sComment>*/
>>

Define_new_bit_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, nMaxOctets, arrsNamedBits, arrsInvariants) ::= <<
<arrsNamedBits:{it|<it>}; separator="\n">

<if(!bFixedSize)>
# nCount equals to Number of bits in the array. Max value is : <nMax>

<endif>

from dataclasses import dataclass

@dataclass(frozen=True)
class <td.typeName>:
    <if(!bFixedSize)>nCount: Int64 = 0 <endif>
    arr: List[UInt8] = []
    
    <arrsInvariants; separator="\n">
    
# TODO: Remove old Scala Code:
# case class <td.typeName>(<if(!bFixedSize)>nCount: Long, <endif>arr: Vector[UByte])
# {
#     <arrsInvariants; separator="\n">
# }
>>

Define_subType_bit_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
type <prTd.typeName> <td.typeName>

# TODO: Remove old Scala Code:
# typedef <prTd.typeName> <td.typeName>
>>

/***********************************       SEQUENCE OF    ************************************************************/


Define_new_sequence_of(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, sChildType, soChildDefinition, arrsSizeClassDefinition, arrsSizeObjDefinition, arrsInvariants) ::= <<

<soChildDefinition>

from dataclasses import dataclass
@dataclass(frozen=True)
class <td.typeName>:
    <if(!bFixedSize)>nCount: Int32 = 0 <endif>
    arr: List[UInt8] = []
    
    <arrsInvariants; separator="\n">

    <arrsSizeClassDefinition; separator="\n\n">
    
object <td.typeName>:
    <arrsSizeObjDefinition; separator="\n\n">
    
# TODO: Remove old Scala Code:
# case class <td.typeName> (<if(!bFixedSize)>nCount: Int, <endif>arr: Vector[<sChildType>])
# {
#     <arrsInvariants; separator="\n">
#
#     <arrsSizeClassDefinition; separator="\n\n">
# }
# object <td.typeName> {
#     <arrsSizeObjDefinition; separator="\n\n">
# }
>>

Define_subType_sequence_of(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize, soChildDefinition) ::= <<

<soChildDefinition>

type <prTd.typeName> <td.typeName>

# TODO: Remove old Scala Code:
# typedef <prTd.typeName> <td.typeName>
>>


/***********************************       SEQUENCE     ************************************************************/

Define_new_sequence_child_bit(sName) ::= "<sName>: Boolean"

Define_new_sequence_child(sName, sType, bIsOptional) ::= <<
<if (bIsOptional)>
<sName>: OptionMut[<sType>]
<else>
<sName>: <sType>
<endif>

# TODO: Remove old Scala Code:
# <if (bIsOptional)>
# <sName>: OptionMut[<sType>]
# <else>
# <sName>: <sType>
# <endif>
>>

Define_new_sequence_save_pos_child(td/*:FE_SequenceTypeDefinition*/, sName, nMaxBytesInACN) ::= "BitStream <sName>;"

Define_new_sequence(td/*:FE_SequenceTypeDefinition*/, arrsChildren, arrsOptionalChildren, arrsChildrenDefinitions, arrsNullFieldsSavePos, arrsSizeDefinition, arrsInvariants) ::= <<
# -- <td.typeName> --------------------------------------------
<arrsChildrenDefinitions; separator= "\n">
<if (arrsNullFieldsSavePos)>

from dataclasses import dataclass

@dataclass(frozen=True)
class <td.extension_function_positions>:
    arrsNullFieldsSavePos; separator="\n">
     <arrsSizeDefinition; separator="\n\n">

# TODO: Remove old Scala Code:
# case class <td.extension_function_positions> (
#     <arrsNullFieldsSavePos; separator="\n">
# ) {
#     <arrsInvariants; separator="\n">
# 
#     <arrsSizeDefinition; separator="\n\n">
# }

<endif>

from dataclasses import dataclass

@dataclass(frozen=True)
class <td.typeName>:
    <arrsChildren:{ch|<ch>}; separator=", \n">
    <arrsInvariants; separator="\n">
    <arrsSizeDefinition; separator="\n\n">


# TODO: Remove old Scala Code:
# case class <td.typeName> (
#     <arrsChildren:{ch|<ch>}; separator=", \n">
# ) {
#     <arrsInvariants; separator="\n">
# 
#     <arrsSizeDefinition; separator="\n\n">
# }

>>

Define_subType_sequence(td/*:FE_SequenceTypeDefinition*/, prTd/*:FE_SequenceTypeDefinition*/, soParentTypePackage, arrsOptionalChildren, arrsExtraDefs) ::= <<
from dataclasses import dataclass

<td.typeName> = <prTd.typeName>

class <td.typeName>:
    <arrsExtraDefs; separator="\n">

<if (arrsNullFieldsSavePos)>
<td.extension_function_positions> = <prTd.extension_function_positions>
<endif>


# TODO: Remove old Scala Code:
# type <td.typeName> = <prTd.typeName>

# object <td.typeName> {
#     <arrsExtraDefs; separator="\n">
# }

# <if (arrsNullFieldsSavePos)>
# type <td.extension_function_positions> = <prTd.extension_function_positions>
# <endif>
>>

/***********************************       CHOICE    ************************************************************/


Define_new_choice_child(sName, sType, sPresent) ::=<<
<sName>: <sType>
>>

Define_new_choice(td/*:FE_ChoiceTypeDefinition*/, sChoiceIDForNone, sFirstChildNamePresent, arrsChildren, arrsPresent, arrsCombined, nIndexMax, arrsChildrenDefinitions, arrsSizeDefinition) ::= <<
#-- <td.typeName> --------------------------------------------
<arrsChildrenDefinitions; separator= "\n">
from enum import Enum
class <td.typeName>(Enum):
    <arrsCombined:{ch|case <ch>}; separator="\n">

    <arrsSizeDefinition; separator="\n\n">
    
# TODO: Remove old Scala Code:
# <arrsChildrenDefinitions; separator= "\n">
# enum <td.typeName>:
#     <arrsCombined:{ch|case <ch>}; separator="\n">
# 
#     <arrsSizeDefinition; separator="\n\n">
>>

Define_subType_choice(td/*:FE_ChoiceTypeDefinition*/, prTd/*:FE_ChoiceTypeDefinition*/, soParentTypePackage) ::= <<
type <prTd.typeName> <td.typeName>

# TODO: Remove old Scala Code:
# typedef <prTd.typeName> <td.typeName>
>>

Define_SubType_int_range(soParentTypePackage, sParentType, noMin, noMax) ::= <<
>>
