group header_python;

rtlModuleName() ::= ""

indentation(sStatement) ::=<<
# header_python.stg 6
    <sStatement>
>>

PrintSpecificationFile(sFileNameWithNoExtUpperCase, sPackageName, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrototypes, arrsUtilityDefines, bHasEncodings, bXer) ::= <<
# header_python.stg 11
"""
Code automatically generated by asn1scc tool
Header / Spec implementation
"""
from asn1pylib.asn1python import *
from typing import *
from enum import Enum, IntEnum
from dataclasses import dataclass, field

<if(arrsIncludedModules)>
# Included Modules: 
<arrsIncludedModules:{inc|import asn1pylib.asn1src.<inc> as <inc>}; separator="\n">
<endif>

from asn1python.asn1_types import Asn1ConstraintValidResult


<if(arrsValueAssignments)>
# Value Assignments (currently not printed! Probably not necessary in Python?):
<!<arrsValueAssignments:{vas|<vas>}; separator="\n">!>
<endif>


# Class Definitions
<arrsTypeAssignments:{tas|<tas>}; separator="\n">

>>

Define_TAS(sTypeDefinition, arrsClassFuncs) ::= <<
# header_python.stg 29
<sTypeDefinition>

    # class implementation indented
    <arrsClassFuncs:{proc|<proc>}; separator="\n\n">

# End of class and related functions
# ================================================================
>>

PrintValueAssignment(sName, sTypeDecl, sValue) ::= <<
# header_python.stg 36
<sName>: <sTypeDecl> = <sValue>  # defined in body
>>

/*
Python TYPES
*/

Declare_Integer() ::="int" // TODO: is this really 64 bit? 
Declare_PosInteger() ::="int" // TODO: is this really 64 bit?
Declare_IntegerNoRTL() ::="LongNoRTL" // TODO
Declare_PosIntegerNoRTL() ::="ULongNoRTL" // TODO

Declare_Boolean() ::= "Asn1Boolean"
Declare_Real() ::= "Asn1Real"

Declare_Int8() ::="int"
Declare_UInt8() ::="int"
Declare_Int16() ::="int"
Declare_UInt16() ::="int"
Declare_Int32() ::="int"
Declare_UInt32() ::="int"
Declare_Int64() ::="int"
Declare_UInt64() ::="int"

Declare_Real32() ::= "Asn1Real32"
Declare_Real64() ::= "Asn1Real64"

Declare_BooleanNoRTL() ::= "Asn1Boolean"
Declare_RealNoRTL() ::= "RealNoRTL"


Declare_Null() ::= "NullType"
Declare_NullNoRTL() ::= "NullType"
Declare_ObjectIdentifier() ::= "INVALID_Asn1ObjectIdentifier"
Declare_ObjectIdentifierNoRTL() ::= "INVALID_Asn1ObjectIdentifier"

Declare_Asn1LocalTime                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTime                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZone     	()::= "Asn1LocalTimeWithTimeZone"
Declare_Asn1Date                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTime            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTime              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZone	()::= "Asn1DateLocalTimeWithTimeZone"

Declare_Asn1LocalTimeNoRTL                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTimeNoRTL                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZoneNoRTL     	()::= "Asn1LocalTimeWithTimeZone"
Declare_Asn1DateNoRTL                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTimeNoRTL            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTimeNoRTL              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZoneNoRTL	()::= "Asn1DateLocalTimeWithTimeZone"


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs, arrsAnnots) ::= <<
# header_python.stg 91
class <sTypeDefinitionName>(<if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>):
    <soExtraDefs>
>>





/******************************************************************************************************************************/
/***********************************       NEW TYPE DEFINITIONS    ************************************************************/
/******************************************************************************************************************************/

/***********************************       ENUMERATED    ************************************************************/

Define_new_enumerated_item(td/*:FE_EnumeratedTypeDefinition*/, sName, nValue) ::= <<
<sName> = <nValue> # header_python.stg 107
>>

Define_new_enumerated_item_macro(td/*:FE_EnumeratedTypeDefinition*/, sAsn1Name, sCName) ::= ""

Define_new_enumerated(td/*:FE_EnumeratedTypeDefinition*/, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax, arrsResolvingMacros) ::= <<
# header_python.stg 130
class <td.typeName>_Enum(Enum):
    <arrsEnumNamesAndValues:{it|<it>}; separator="\n">

@dataclass(frozen=True)
class <td.typeName>(Asn1Base):
    # initialize val with the first enum element by default
    val: <td.typeName>_Enum = <td.typeName>_Enum.<first(arrsEnumNames)>
>>

Define_subType_enumerated(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, soParentTypePackage) ::= <<
class <prTd.typeName>(<td.typeName>): # header_python.stg 125
>>

Define_new_enumerated_private(td/*:FE_EnumeratedTypeDefinition*/, arrsValidEnumNames, arrsEnumNames) ::= <<
>>

Define_subType_enumerated_private(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, arrsValidEnumNames, arrsEnumNames) ::= <<
>>

/***********************************       STRING    ************************************************************/

Define_new_ia5string(td/*:FE_StringTypeDefinition*/, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
# todo: maybe ia5 string needs to inherit from Asn1Base as well?
class <td.typeName>(List[int]): # header_python.stg 137
>>

Define_subType_ia5string(td/*:FE_StringTypeDefinition*/, prTd/*:FE_StringTypeDefinition*/, soParentTypePackage) ::= <<
class <prTd.typeName>(<td.typeName>): # header_python.stg 141
>>

/***********************************       OCTET STRING    ************************************************************/

Define_new_octet_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, arrsInvariants) ::= <<
# header_python.stg 147
<if(!bFixedSize)>
# nCount equals to Number of bytes in the array. Max value is : <nMax> (unsure - TODO read asn1 standard)

<endif>

@dataclass(frozen=True)
class <td.typeName>(Asn1Base):
    <if(!bFixedSize)>    nCount: int = 0<endif>
    arr: List[int] = field(default_factory=list)
    
    <arrsInvariants; separator="\n">
>>

Define_subType_octet_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
class <prTd.typeName>(<td.typeName>): # header_python.stg 164
>>

/***********************************       BIT STRING    ************************************************************/

Define_new_bit_string_named_bit(td/*:FE_SizeableTypeDefinition*/, sTargetLangBitName, sHexValue, sComment) ::= <<
# TODO: Unclear what to do here
<td.typeName>_<sTargetLangBitName> = 0x<sHexValue>  /*<sComment>*/
>>

Define_new_bit_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, nMaxOctets, arrsNamedBits, arrsInvariants) ::= <<
# header_python.stg 175
<arrsNamedBits:{it|<it>}; separator="\n">

<if(!bFixedSize)>
# nCount equals to Number of bits in the array. Max value is : <nMax>

<endif>

@dataclass(frozen=True)
class <td.typeName>(Asn1Base):
    <if(!bFixedSize)>    nCount: int = 0<endif>
    arr: List[int] = field(default_factory=list)
    
    <arrsInvariants; separator="\n">
>>

Define_subType_bit_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
class <prTd.typeName>(<td.typeName>): # header_python.stg 194
>>

/***********************************       SEQUENCE OF    ************************************************************/


Define_new_sequence_of(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, sChildType, soChildDefinition, arrsSizeClassDefinition, arrsSizeObjDefinition, arrsInvariants) ::= <<
# header_python.stg 201
<soChildDefinition>

@dataclass(frozen=True)
class <td.typeName>(Asn1Base):
    <if(!bFixedSize)>    nCount: int = 0<endif>
    arr: List[int] = field(default_factory=list)
    
    <arrsInvariants; separator="\n">

    <arrsSizeClassDefinition; separator="\n\n">
    
    <if(arrsSizeObjDefinition)>
# TODO is this required?
# object <td.typeName>:
    # <arrsSizeObjDefinition; separator="\n\n">
    <endif>
>>

Define_subType_sequence_of(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize, soChildDefinition) ::= <<
# header_python.stg 222
<soChildDefinition>

class <prTd.typeName>(<td.typeName>):
>>


/***********************************       SEQUENCE     ************************************************************/

Define_new_sequence_child_bit(sName) ::= "<sName>: Boolean # header_python.stg 231"

Define_new_sequence_child(sName, sType, bIsOptional) ::= <<
# header_python.stg 234
<if (bIsOptional)>
<sName>: Optional[<sType>]
<else>
<sName>: <sType>
<endif>
>>

Define_new_sequence_save_pos_child(td/*:FE_SequenceTypeDefinition*/, sName, nMaxBytesInACN) ::= "BitStream <sName> # header_python.stg 242"

Define_new_sequence(td/*:FE_SequenceTypeDefinition*/, arrsChildren, arrsOptionalChildren, arrsChildrenDefinitions, arrsNullFieldsSavePos, arrsSizeDefinition, arrsInvariants) ::= <<
# header_python.stg 245
# -- <td.typeName> --------------------------------------------
<arrsChildrenDefinitions; separator= "\n">
<if (arrsNullFieldsSavePos)>

@dataclass(frozen=True)
class <td.extension_function_positions>:
    <arrsNullFieldsSavePos; separator="\n">
    <arrsSizeDefinition; separator="\n\n">
<endif>

@dataclass(frozen=True)
class <td.typeName>(Asn1Base):
    <arrsChildren:{ch|<ch>}; separator="\n">
    <arrsInvariants; separator="\n">
    <arrsSizeDefinition; separator="\n\n">
>>

Define_subType_sequence(td/*:FE_SequenceTypeDefinition*/, prTd/*:FE_SequenceTypeDefinition*/, soParentTypePackage, arrsOptionalChildren, arrsExtraDefs) ::= <<
# header_python.stg 268
@dataclass(frozen=True)
class <td.typeName>(<if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.typeName>):
    <arrsExtraDefs; separator="\n">

<if (arrsNullFieldsSavePos)>
    <td.extension_function_positions> = <prTd.extension_function_positions>
<endif>
>>

/***********************************       CHOICE    ************************************************************/


Define_new_choice_child(sName, sType, sPresent) ::=<<
<sType>
>>

Define_new_choice(td/*:FE_ChoiceTypeDefinition*/, sChoiceIDForNone, sFirstChildNamePresent, arrsChildrenTypes, arrsPresent, arrsCombined, nIndexMax, arrsChildrenDefinitions, arrsSizeDefinition) ::= <<
# header_python.stg 289
#-- <td.typeName> --------------------------------------------
<arrsChildrenDefinitions; separator= "\n">

class <td.typeName>InUse(Enum):
    <arrsPresent:{ch|<ch> = <i0>}; separator="\n">

class <td.typeName>(Asn1Base):
    # which selection element is in use
    kind: <td.typeName>InUse = <td.typeName>InUse.<first(arrsPresent)>
    
    # actual selection element
    data: Union[<arrsChildrenTypes:{t|<t>}; separator=", ">] = NullType()

    <arrsSizeDefinition; separator="\n\n">
>>

Define_subType_choice(td/*:FE_ChoiceTypeDefinition*/, prTd/*:FE_ChoiceTypeDefinition*/, soParentTypePackage) ::= <<
type <prTd.typeName> <td.typeName> # header_python.stg 300
>>

Define_SubType_int_range(soParentTypePackage, sParentType, noMin, noMax) ::= <<
>>
