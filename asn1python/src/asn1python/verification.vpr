domain PyType  {
  
  function extends_(sub: PyType, super: PyType): Bool 
  
  function issubtype(sub: PyType, super: PyType): Bool 
  
  function isnotsubtype(sub: PyType, super: PyType): Bool 
  
  function tuple_args(t: PyType): Seq[PyType] 
  
  unique function union_basic(): PyType 
  
  function typeof(obj: Ref): PyType 
  
  function get_basic(t: PyType): PyType 
  
  function union_type_1(arg_1: PyType): PyType 
  
  function union_type_2(arg_1: PyType, arg_2: PyType): PyType 
  
  function union_type_3(arg_1: PyType, arg_2: PyType, arg_3: PyType): PyType 
  
  function union_type_4(arg_1: PyType, arg_2: PyType, arg_3: PyType, arg_4: PyType): PyType 
  
  unique function object(): PyType 
  
  unique function list_basic(): PyType 
  
  function list(arg0: PyType): PyType 
  
  function list_arg(typ: PyType, index: Int): PyType 
  
  unique function set_basic(): PyType 
  
  function set(arg0: PyType): PyType 
  
  function set_arg(typ: PyType, index: Int): PyType 
  
  unique function dict_basic(): PyType 
  
  function dict(arg0: PyType, arg1: PyType): PyType 
  
  function dict_arg(typ: PyType, index: Int): PyType 
  
  unique function int(): PyType 
  
  unique function float(): PyType 
  
  unique function bool(): PyType 
  
  unique function NoneType(): PyType 
  
  unique function Exception(): PyType 
  
  unique function ConnectionRefusedError(): PyType 
  
  unique function traceback(): PyType 
  
  unique function str(): PyType 
  
  unique function bytes(): PyType 
  
  unique function bytearray(): PyType 
  
  unique function tuple_basic(): PyType 
  
  function tuple(args: Seq[PyType]): PyType 
  
  function tuple_arg(typ: PyType, index: Int): PyType 
  
  unique function __prim__perm(): PyType 
  
  unique function PSeq_basic(): PyType 
  
  function PSeq(arg0: PyType): PyType 
  
  function PSeq_arg(typ: PyType, index: Int): PyType 
  
  unique function PByteSeq(): PyType 
  
  unique function PSet_basic(): PyType 
  
  function PSet(arg0: PyType): PyType 
  
  function PSet_arg(typ: PyType, index: Int): PyType 
  
  unique function PMultiset_basic(): PyType 
  
  function PMultiset(arg0: PyType): PyType 
  
  function PMultiset_arg(typ: PyType, index: Int): PyType 
  
  unique function slice(): PyType 
  
  unique function range_0(): PyType 
  
  unique function Iterator_basic(): PyType 
  
  function Iterator(arg0: PyType): PyType 
  
  function Iterator_arg(typ: PyType, index: Int): PyType 
  
  unique function Thread_0(): PyType 
  
  unique function LevelType(): PyType 
  
  unique function type(): PyType 
  
  unique function Place(): PyType 
  
  unique function __prim__Seq_type(): PyType 
  
  axiom issubtype_transitivity {
    (forall sub: PyType, middle: PyType, super: PyType ::
      { issubtype(sub, middle), issubtype(middle, super) }
      { issubtype(sub, super), issubtype(middle, super) }
      { issubtype(sub, middle), issubtype(sub, super) }
      issubtype(sub, middle) && issubtype(middle, super) ==>
      issubtype(sub, super))
  }
  
  axiom issubtype_reflexivity {
    (forall type_: PyType ::
      { issubtype(type_, type_) }
      issubtype(type_, type_))
  }
  
  axiom extends_implies_subtype {
    (forall sub: PyType, sub2: PyType ::
      { extends_(sub, sub2) }
      extends_(sub, sub2) ==> issubtype(sub, sub2))
  }
  
  axiom null_nonetype {
    (forall r: Ref ::
      { typeof(r) }
      issubtype(typeof(r), NoneType()) == (r == null))
  }
  
  axiom nothing_has_union_type {
    (forall r: Ref :: { typeof(r) } get_basic(typeof(r)) != union_basic())
  }
  
  axiom issubtype_object {
    (forall type_: PyType ::
      { issubtype(type_, object()) }
      issubtype(type_, object()))
  }
  
  axiom issubtype_exclusion {
    (forall sub: PyType, sub2: PyType, super: PyType ::
      { extends_(sub, super), extends_(sub2, super) }
      extends_(sub, super) && extends_(sub2, super) && sub != sub2 ==>
      isnotsubtype(sub, sub2) && isnotsubtype(sub2, sub))
  }
  
  axiom issubtype_exclusion_2 {
    (forall sub: PyType, super: PyType ::
      { issubtype(sub, super) }
      { issubtype(super, sub) }
      issubtype(sub, super) && sub != super ==> !issubtype(super, sub))
  }
  
  axiom issubtype_exclusion_propagation {
    (forall sub: PyType, middle: PyType, super: PyType ::
      { issubtype(sub, middle), isnotsubtype(middle, super) }
      issubtype(sub, middle) && isnotsubtype(middle, super) ==>
      !issubtype(sub, super))
  }
  
  axiom union_basic_1 {
    (forall arg_1: PyType ::
      { union_type_1(arg_1) }
      get_basic(union_type_1(arg_1)) == union_basic())
  }
  
  axiom union_basic_2 {
    (forall arg_1: PyType, arg_2: PyType ::
      { union_type_2(arg_1, arg_2) }
      get_basic(union_type_2(arg_1, arg_2)) == union_basic())
  }
  
  axiom union_basic_3 {
    (forall arg_1: PyType, arg_2: PyType, arg_3: PyType ::
      { union_type_3(arg_1, arg_2, arg_3) }
      get_basic(union_type_3(arg_1, arg_2, arg_3)) == union_basic())
  }
  
  axiom union_basic_4 {
    (forall arg_1: PyType, arg_2: PyType, arg_3: PyType, arg_4: PyType ::
      { union_type_4(arg_1, arg_2, arg_3, arg_4) }
      get_basic(union_type_4(arg_1, arg_2, arg_3, arg_4)) == union_basic())
  }
  
  axiom union_subtype_1 {
    (forall arg_1: PyType, X: PyType ::
      { issubtype(X, union_type_1(arg_1)) }
      get_basic(X) != union_basic() ==>
      issubtype(X, union_type_1(arg_1)) == (false || issubtype(X, arg_1)))
  }
  
  axiom union_subtype_2 {
    (forall arg_1: PyType, arg_2: PyType, X: PyType ::
      { issubtype(X, union_type_2(arg_1, arg_2)) }
      get_basic(X) != union_basic() ==>
      issubtype(X, union_type_2(arg_1, arg_2)) ==
      (false || issubtype(X, arg_1) || issubtype(X, arg_2)))
  }
  
  axiom union_subtype_3 {
    (forall arg_1: PyType, arg_2: PyType, arg_3: PyType, X: PyType ::
      { issubtype(X, union_type_3(arg_1, arg_2, arg_3)) }
      get_basic(X) != union_basic() ==>
      issubtype(X, union_type_3(arg_1, arg_2, arg_3)) ==
      (false || issubtype(X, arg_1) || issubtype(X, arg_2) ||
      issubtype(X, arg_3)))
  }
  
  axiom union_subtype_4 {
    (forall arg_1: PyType, arg_2: PyType, arg_3: PyType, arg_4: PyType, X: PyType ::
      { issubtype(X, union_type_4(arg_1, arg_2, arg_3, arg_4)) }
      get_basic(X) != union_basic() ==>
      issubtype(X, union_type_4(arg_1, arg_2, arg_3, arg_4)) ==
      (false || issubtype(X, arg_1) || issubtype(X, arg_2) ||
      issubtype(X, arg_3) ||
      issubtype(X, arg_4)))
  }
  
  axiom subtype_union_1 {
    (forall arg_1: PyType, X: PyType ::
      { issubtype(union_type_1(arg_1), X) }
      issubtype(union_type_1(arg_1), X) == (true && issubtype(arg_1, X)))
  }
  
  axiom subtype_union_2 {
    (forall arg_1: PyType, arg_2: PyType, X: PyType ::
      { issubtype(union_type_2(arg_1, arg_2), X) }
      issubtype(union_type_2(arg_1, arg_2), X) ==
      (true && issubtype(arg_1, X) && issubtype(arg_2, X)))
  }
  
  axiom subtype_union_3 {
    (forall arg_1: PyType, arg_2: PyType, arg_3: PyType, X: PyType ::
      { issubtype(union_type_3(arg_1, arg_2, arg_3), X) }
      issubtype(union_type_3(arg_1, arg_2, arg_3), X) ==
      (true && issubtype(arg_1, X) && issubtype(arg_2, X) &&
      issubtype(arg_3, X)))
  }
  
  axiom subtype_union_4 {
    (forall arg_1: PyType, arg_2: PyType, arg_3: PyType, arg_4: PyType, X: PyType ::
      { issubtype(union_type_4(arg_1, arg_2, arg_3, arg_4), X) }
      issubtype(union_type_4(arg_1, arg_2, arg_3, arg_4), X) ==
      (true && issubtype(arg_1, X) && issubtype(arg_2, X) &&
      issubtype(arg_3, X) &&
      issubtype(arg_4, X)))
  }
  
  axiom subtype_list {
    (forall var0: PyType ::
      { list(var0) }
      extends_(list(var0), object()) &&
      get_basic(list(var0)) == list_basic())
  }
  
  axiom list_args0 {
    (forall Z: PyType, arg0: PyType ::
      { list(arg0), list_arg(Z, 0) }
      issubtype(Z, list(arg0)) ==> list_arg(Z, 0) == arg0)
  }
  
  axiom subtype_set {
    (forall var0: PyType ::
      { set(var0) }
      extends_(set(var0), object()) && get_basic(set(var0)) == set_basic())
  }
  
  axiom set_args0 {
    (forall Z: PyType, arg0: PyType ::
      { set(arg0), set_arg(Z, 0) }
      issubtype(Z, set(arg0)) ==> set_arg(Z, 0) == arg0)
  }
  
  axiom subtype_dict {
    (forall var0: PyType, var1: PyType ::
      { dict(var0, var1) }
      extends_(dict(var0, var1), object()) &&
      get_basic(dict(var0, var1)) == dict_basic())
  }
  
  axiom dict_args0 {
    (forall Z: PyType, arg0: PyType, arg1: PyType ::
      { dict(arg0, arg1), dict_arg(Z, 0) }
      issubtype(Z, dict(arg0, arg1)) ==> dict_arg(Z, 0) == arg0)
  }
  
  axiom dict_args1 {
    (forall Z: PyType, arg0: PyType, arg1: PyType ::
      { dict(arg0, arg1), dict_arg(Z, 1) }
      issubtype(Z, dict(arg0, arg1)) ==> dict_arg(Z, 1) == arg1)
  }
  
  axiom subtype_int {
    extends_(int(), float()) && get_basic(int()) == int()
  }
  
  axiom subtype_float {
    extends_(float(), object()) && get_basic(float()) == float()
  }
  
  axiom subtype_bool {
    extends_(bool(), int()) && get_basic(bool()) == bool()
  }
  
  axiom subtype_NoneType {
    extends_(NoneType(), object()) && get_basic(NoneType()) == NoneType()
  }
  
  axiom subtype_Exception {
    extends_(Exception(), object()) &&
    get_basic(Exception()) == Exception()
  }
  
  axiom subtype_ConnectionRefusedError {
    extends_(ConnectionRefusedError(), Exception()) &&
    get_basic(ConnectionRefusedError()) == ConnectionRefusedError()
  }
  
  axiom subtype_traceback {
    extends_(traceback(), object()) &&
    get_basic(traceback()) == traceback()
  }
  
  axiom subtype_str {
    extends_(str(), object()) && get_basic(str()) == str()
  }
  
  axiom subtype_bytes {
    extends_(bytes(), object()) && get_basic(bytes()) == bytes()
  }
  
  axiom subtype_bytearray {
    extends_(bytearray(), object()) &&
    get_basic(bytearray()) == bytearray()
  }
  
  axiom subtype___prim__perm {
    extends_(__prim__perm(), object()) &&
    get_basic(__prim__perm()) == __prim__perm()
  }
  
  axiom subtype_PSeq {
    (forall var0: PyType ::
      { PSeq(var0) }
      extends_(PSeq(var0), object()) &&
      get_basic(PSeq(var0)) == PSeq_basic())
  }
  
  axiom PSeq_args0 {
    (forall Z: PyType, arg0: PyType ::
      { PSeq(arg0), PSeq_arg(Z, 0) }
      issubtype(Z, PSeq(arg0)) ==> PSeq_arg(Z, 0) == arg0)
  }
  
  axiom subtype_PByteSeq {
    extends_(PByteSeq(), object()) && get_basic(PByteSeq()) == PByteSeq()
  }
  
  axiom subtype_PSet {
    (forall var0: PyType ::
      { PSet(var0) }
      extends_(PSet(var0), object()) &&
      get_basic(PSet(var0)) == PSet_basic())
  }
  
  axiom PSet_args0 {
    (forall Z: PyType, arg0: PyType ::
      { PSet(arg0), PSet_arg(Z, 0) }
      issubtype(Z, PSet(arg0)) ==> PSet_arg(Z, 0) == arg0)
  }
  
  axiom subtype_PMultiset {
    (forall var0: PyType ::
      { PMultiset(var0) }
      extends_(PMultiset(var0), object()) &&
      get_basic(PMultiset(var0)) == PMultiset_basic())
  }
  
  axiom PMultiset_args0 {
    (forall Z: PyType, arg0: PyType ::
      { PMultiset(arg0), PMultiset_arg(Z, 0) }
      issubtype(Z, PMultiset(arg0)) ==> PMultiset_arg(Z, 0) == arg0)
  }
  
  axiom subtype_slice {
    extends_(slice(), object()) && get_basic(slice()) == slice()
  }
  
  axiom subtype_range_0 {
    extends_(range_0(), object()) && get_basic(range_0()) == range_0()
  }
  
  axiom subtype_Iterator {
    (forall var0: PyType ::
      { Iterator(var0) }
      extends_(Iterator(var0), object()) &&
      get_basic(Iterator(var0)) == Iterator_basic())
  }
  
  axiom Iterator_args0 {
    (forall Z: PyType, arg0: PyType ::
      { Iterator(arg0), Iterator_arg(Z, 0) }
      issubtype(Z, Iterator(arg0)) ==> Iterator_arg(Z, 0) == arg0)
  }
  
  axiom subtype_Thread_0 {
    extends_(Thread_0(), object()) && get_basic(Thread_0()) == Thread_0()
  }
  
  axiom subtype_LevelType {
    extends_(LevelType(), object()) &&
    get_basic(LevelType()) == LevelType()
  }
  
  axiom subtype_type {
    extends_(type(), object()) && get_basic(type()) == type()
  }
  
  axiom subtype_Place {
    extends_(Place(), object()) && get_basic(Place()) == Place()
  }
  
  axiom subtype___prim__Seq_type {
    extends_(__prim__Seq_type(), object()) &&
    get_basic(__prim__Seq_type()) == __prim__Seq_type()
  }
}

domain SIFDomain[T]  {
  
  function Low(x: T): Bool 
  
  function LowEvent(): Bool 
  
  axiom low_true {
    (forall x: T :: { (Low(x): Bool) } (Low(x): Bool))
  }
  
  axiom lowevent_true {
    (LowEvent(): Bool)
  }
}

domain ___intbv interpretation (SMTLIB: "(_ BitVec 8)", Boogie: "bv8") {
  
  function toBVInt(i: Int): ___intbv interpretation "(_ int2bv 8)"
  
  function fromBVInt(___intbv): Int interpretation "bv2int"
  
  function andBVInt(___intbv, ___intbv): ___intbv interpretation "bvand"
  
  function orBVInt(___intbv, ___intbv): ___intbv interpretation "bvor"
  
  function xorBVInt(___intbv, ___intbv): ___intbv interpretation "bvxor"
  
  function shlBVInt(___intbv, ___intbv): ___intbv interpretation "bvshl"
  
  function shrBVInt(___intbv, ___intbv): ___intbv interpretation "bvlshr"
  
  function notBVInt(___intbv): ___intbv interpretation "bvnot"
}

domain IntWellFoundedOrder  {
  
  axiom integer_ax_dec {
    (forall int1: Int, int2: Int ::
      { (decreasing(int1, int2): Bool) }
      int1 < int2 ==> (decreasing(int1, int2): Bool))
  }
  
  axiom integer_ax_bound {
    (forall int1: Int ::
      { (bounded(int1): Bool) }
      int1 >= 0 ==> (bounded(int1): Bool))
  }
}

domain WellFoundedOrder[T]  {
  
  function decreasing(arg1: T, arg2: T): Bool 
  
  function bounded(arg1: T): Bool 
}

domain PredicateInstancesWellFoundedOrder  {
  
  axiom predicate_instances_ax_dec {
    (forall l1: PredicateInstance, l2: PredicateInstance ::
      { nestedPredicates(l1, l2) }
      (decreasing(l1, l2): Bool) == nestedPredicates(l1, l2))
  }
  
  axiom predicate_instances_ax_bound {
    (forall l1: PredicateInstance ::
      { (bounded(l1): Bool) }
      (bounded(l1): Bool))
  }
}

domain PredicateInstancesNestedRelation  {
  
  function nestedPredicates(l1: PredicateInstance, l2: PredicateInstance): Bool 
  
  axiom nestedTrans {
    (forall l1: PredicateInstance, l2: PredicateInstance, l3: PredicateInstance ::
      { nestedPredicates(l1, l2), nestedPredicates(l2, l3) }
      nestedPredicates(l1, l2) && nestedPredicates(l2, l3) ==>
      nestedPredicates(l1, l3))
  }
  
  axiom nestedReflex {
    (forall l1: PredicateInstance ::!nestedPredicates(l1, l1))
  }
}

domain PredicateInstance  {
  
  
}

domain ____pow_helper  {
  
  function ___pow(Int, Int): Int 
  
  axiom {
    (forall i1: Int :: { ___pow(i1, 0) } ___pow(i1, 0) == 1)
  }
  
  axiom {
    (forall i1: Int, i2: Int ::
      { ___pow(i1, i2) }
      i2 > 0 ==> ___pow(i1, i2) == i1 * ___pow(i1, i2 - 1))
  }
}

domain __ObjectEquality  {
  
  function object___eq__(Ref, Ref): Bool 
  
  axiom {
    (forall o1: Ref, o2: Ref, o3: Ref ::
      { object___eq__(o1, o2), object___eq__(o2, o3) }
      { object___eq__(o1, o2), object___eq__(o1, o3) }
      { object___eq__(o2, o3), object___eq__(o1, o3) }
      object___eq__(o1, o2) && object___eq__(o2, o3) ==>
      object___eq__(o1, o3))
  }
  
  axiom {
    (forall o1: Ref, o2: Ref ::
      { object___eq__(o1, o2) }
      object___eq__(o1, o2) == object___eq__(o2, o1) &&
      ((o1 == o2 ==> object___eq__(o1, o2)) &&
      ((o1 == null) != (o2 == null) ==> !object___eq__(o1, o2))))
  }
}

domain __SumHelper[T$]  {
  
  function __sum(s: Seq[Int]): Int 
  
  axiom __sum_def_1 {
    (__sum(Seq[Int]()): Int) == 0
  }
  
  axiom __sum_def_2 {
    (forall __t: Int ::
      { (__sum(Seq(__t)): Int) }
      (__sum(Seq(__t)): Int) == __t)
  }
  
  axiom __sum_def_3 {
    (forall __ss1: Seq[Int], __ss2: Seq[Int] ::
      { (__sum(__ss1 ++ __ss2): Int) }
      (__sum(__ss1 ++ __ss2): Int) ==
      (__sum(__ss1): Int) + (__sum(__ss2): Int))
  }
  
  axiom __sum_def_4 {
    (forall __ss1: Seq[Int], __ss2: Seq[Int] ::
      { (__sum(__ss1): Int), (__sum(__ss2): Int) }
      (__toMS(__ss1): Multiset[Int]) == (__toMS(__ss2): Multiset[Int]) ==>
      (__sum(__ss1): Int) == (__sum(__ss2): Int))
  }
}

domain _list_ce_helper  {
  
  function seq_ref_length(___s: Seq[Ref]): Int 
  
  function seq_ref_index(___s: Seq[Ref], i: Int): Ref 
  
  axiom relate_length {
    (forall ___s: Seq[Ref] :: { |___s| } |___s| == seq_ref_length(___s))
  }
  
  axiom relate_index {
    (forall ___s: Seq[Ref], ___i: Int ::
      { ___s[___i] }
      ___s[___i] == seq_ref_index(___s, ___i))
  }
}

domain Measure$  {
  
  function Measure$create(guard: Bool, key: Ref, value: Int): Measure$ 
  
  function Measure$guard(m: Measure$): Bool 
  
  function Measure$key(m: Measure$): Ref 
  
  function Measure$value(m: Measure$): Int 
  
  axiom Measure$A0 {
    (forall g: Bool, k: Ref, v: Int ::
      { Measure$guard(Measure$create(g, k, v)) }
      Measure$guard(Measure$create(g, k, v)) == g)
  }
  
  axiom Measure$A1 {
    (forall g: Bool, k: Ref, v: Int ::
      { Measure$key(Measure$create(g, k, v)) }
      Measure$key(Measure$create(g, k, v)) == k)
  }
  
  axiom Measure$A2 {
    (forall g: Bool, k: Ref, v: Int ::
      { Measure$value(Measure$create(g, k, v)) }
      Measure$value(Measure$create(g, k, v)) == v)
  }
}

domain __MSHelper[T$]  {
  
  function __toMS(s: Seq[T$]): Multiset[T$] 
  
  axiom __toMS_def_1 {
    (__toMS(Seq[T$]()): Multiset[T$]) == Multiset[T$]()
  }
  
  axiom __toMS_def_2 {
    (forall __t: T$ ::
      { (__toMS(Seq(__t)): Multiset[T$]) }
      (__toMS(Seq(__t)): Multiset[T$]) == Multiset(__t))
  }
  
  axiom __toMS_def_3 {
    (forall __ss1: Seq[T$], __ss2: Seq[T$] ::
      { (__toMS(__ss1 ++ __ss2): Multiset[T$]) }
      (__toMS(__ss1 ++ __ss2): Multiset[T$]) ==
      ((__toMS(__ss1): Multiset[T$]) union (__toMS(__ss2): Multiset[T$])))
  }
  
  axiom __toMS_def_4 {
    (forall __ss1: Seq[T$] ::
      { (__toMS(__ss1): Multiset[T$]) }
      |(__toMS(__ss1): Multiset[T$])| == |__ss1|)
  }
}

domain tuple_types  {
  
  function tuple_var(arg0: PyType): PyType 
  
  function tuple_var_arg(arg0: PyType): PyType 
  
  axiom tuple_arg_def {
    (forall seq: Seq[PyType], i: Int, Z: PyType ::
      { issubtype(Z, tuple(seq)), tuple_arg(Z, i) }
      issubtype(Z, tuple(seq)) ==> issubtype(tuple_arg(Z, i), seq[i]))
  }
  
  axiom tuple_arg_def_2 {
    (forall arg0: PyType, i: Int, Z: PyType ::
      { issubtype(Z, tuple_var(arg0)), tuple_arg(Z, i) }
      issubtype(Z, tuple_var(arg0)) ==> issubtype(tuple_arg(Z, i), arg0))
  }
  
  axiom tuple_args_def {
    (forall seq: Seq[PyType], Z: PyType ::
      { issubtype(Z, tuple(seq)) }
      issubtype(Z, tuple(seq)) ==> |tuple_args(Z)| == |seq|)
  }
  
  axiom tuple_self_subtype {
    (forall seq1: Seq[PyType], seq2: Seq[PyType] ::seq1 != seq2 &&
      (|seq1| == |seq2| &&
      (forall i: Int ::i >= 0 && i < |seq1| ==> issubtype(seq1[i], seq2[i]))) ==>
      issubtype(tuple(seq1), tuple(seq2)))
  }
  
  axiom subtype_tuple {
    (forall args: Seq[PyType] ::
      { tuple(args) }
      (forall e: PyType ::(e in args) ==> e == object()) ==>
      extends_(tuple(args), object()))
  }
  
  axiom subtype_tuple_var {
    (forall var0: PyType ::
      { tuple_var(var0) }
      issubtype(tuple_var(var0), object()))
  }
  
  axiom subtype_tuple_var_self {
    (forall var0: PyType, var1: PyType ::
      { issubtype(tuple_var(var0), tuple_var(var1)) }
      issubtype(tuple_var(var0), tuple_var(var1)) == issubtype(var0, var1))
  }
  
  axiom subtype_tuple_var_tuple {
    (forall var0: PyType, var1: Seq[PyType] ::
      { issubtype(tuple(var1), tuple_var(var0)) }
      issubtype(tuple(var1), tuple_var(var0)) ==
      (forall i: Int ::
        { issubtype(var1[i], var0) }
        i >= 0 && i < |var1| ==> issubtype(var1[i], var0)))
  }
  
  axiom tuple_args_subtype_1 {
    (forall seq: Seq[PyType], Z: PyType ::
      { issubtype(Z, tuple(seq)), issubtype(Z, tuple(tuple_args(Z))) }
      issubtype(Z, tuple(seq)) ==> issubtype(Z, tuple(tuple_args(Z))))
  }
  
  axiom tuple_args_subtype_2 {
    (forall Z: PyType, arg0: PyType ::
      { issubtype(Z, tuple(tuple_args(Z))), issubtype(Z, tuple_var(arg0)) }
      issubtype(Z, tuple_var(arg0)) ==> issubtype(Z, tuple(tuple_args(Z))))
  }
  
  axiom tuple_type_basic_1 {
    (forall seq: Seq[PyType], Z: PyType, arg1: PyType ::
      { issubtype(Z, tuple(seq)), issubtype(Z, arg1) }
      issubtype(Z, tuple(seq)) && issubtype(Z, arg1) ==>
      get_basic(arg1) == tuple_basic() ||
      (get_basic(arg1) == object() || get_basic(arg1) == union_basic()))
  }
  
  axiom tuple_type_basic_2 {
    (forall arg0: PyType, arg1: PyType, Z: PyType ::
      { issubtype(Z, tuple_var(arg0)), issubtype(Z, arg1) }
      issubtype(Z, tuple_var(arg0)) && issubtype(Z, arg1) ==>
      get_basic(arg1) == tuple_basic() ||
      (get_basic(arg1) == object() || get_basic(arg1) == union_basic()))
  }
}

domain _Name  {
  
  function _combine(n1: _Name, n2: _Name): _Name 
  
  function _single(n: Int): _Name 
  
  function _get_combined_prefix(n: _Name): _Name 
  
  function _get_combined_name(n: _Name): _Name 
  
  function _get_value(n: _Name): Int 
  
  function _name_type(n: _Name): Bool 
  
  function _is_single(n: _Name): Bool 
  
  function _is_combined(n: _Name): Bool 
  
  axiom decompose_single {
    (forall i: Int :: { _single(i) } _get_value(_single(i)) == i)
  }
  
  axiom compose_single {
    (forall n: _Name ::
      { _get_value(n) }
      _is_single(n) ==> n == _single(_get_value(n)))
  }
  
  axiom type_of_single {
    (forall i: Int :: { _single(i) } _name_type(_single(i)))
  }
  
  axiom decompose_combined {
    (forall n1: _Name, n2: _Name ::
      { _combine(n1, n2) }
      _get_combined_prefix(_combine(n1, n2)) == n1 &&
      _get_combined_name(_combine(n1, n2)) == n2)
  }
  
  axiom compose_combined {
    (forall n: _Name ::
      { _get_combined_prefix(n) }
      { _get_combined_name(n) }
      _is_combined(n) ==>
      n == _combine(_get_combined_prefix(n), _get_combined_name(n)))
  }
  
  axiom type_of_composed {
    (forall n1: _Name, n2: _Name ::
      { _combine(n1, n2) }
      !_name_type(_combine(n1, n2)))
  }
  
  axiom type_is_single {
    (forall n: _Name :: { _name_type(n) } _name_type(n) == _is_single(n))
  }
  
  axiom type_is_combined {
    (forall n: _Name ::
      { _name_type(n) }
      !_name_type(n) == _is_combined(n))
  }
}

field _val: Ref

field __container: Ref

field __iter_index: Int

field __previous: Seq[Ref]

field list_acc: Seq[Ref]

field set_acc: Set[Ref]

field dict_acc: Map[Ref,Ref]

field bytearray_acc: Seq[Int]

field Measure$acc: Seq[Ref]

field MustReleaseBounded: Int

field MustReleaseUnbounded: Int

function _isDefined(id: Int): Bool


function _checkDefined(val: Ref, id: Int): Ref
  requires _isDefined(id)
{
  val
}

function floor_align_byte(position: Ref): Ref
  requires issubtype(typeof(position), int())
  ensures issubtype(typeof(result), int())
{
  __prim__int___box__(int___mul__(int___floordiv__(int___unbox__(position),
  int___unbox__(NO_OF_BITS_IN_BYTE())), int___unbox__(NO_OF_BITS_IN_BYTE())))
}

function byteseq_bytes_equal_until(b1: Ref, b2: Ref, end: Int): Ref
  requires issubtype(typeof(b1), PByteSeq())
  requires issubtype(typeof(b2), PByteSeq())
  requires int___le__(__prim__int___box__(PByteSeq___len__(b1)), __prim__int___box__(PByteSeq___len__(b2)))
  requires int___le__(__prim__int___box__(0), __prim__int___box__(end)) &&
    int___le__(__prim__int___box__(end), __prim__int___box__(PByteSeq___len__(b1)))
  ensures issubtype(typeof(result), bool())
  decreases _
{
  __prim__bool___box__(PByteSeq___eq__(PByteSeq_take(b1, end), PByteSeq_take(b2,
  end)))
}

@opaque()
function byteseq_bits_equal_until(b1_0: Ref, b2_0: Ref, end_0: Int): Ref
  requires issubtype(typeof(b1_0), PByteSeq())
  requires issubtype(typeof(b2_0), PByteSeq())
  requires int___le__(__prim__int___box__(PByteSeq___len__(b1_0)), __prim__int___box__(PByteSeq___len__(b2_0)))
  requires int___le__(__prim__int___box__(0), __prim__int___box__(end_0)) &&
    int___le__(__prim__int___box__(end_0), __prim__int___box__(int___mul__(PByteSeq___len__(b1_0),
    int___unbox__(NO_OF_BITS_IN_BYTE()))))
  ensures issubtype(typeof(result), bool())
  ensures PByteSeq___eq__(b1_0, b2_0) ==> bool___unbox__(result)
  decreases _
{
  (let cond_1 ==
    (__prim__bool___box__(int___eq__(__prim__int___box__(end_0), __prim__int___box__(0)))) in
    (true && bool___unbox__(cond_1) ?
      __prim__bool___box__(true) :
      (let full_bytes_1 ==
        (__prim__int___box__(int___floordiv__(end_0, int___unbox__(NO_OF_BITS_IN_BYTE())))) in
        (let bit_position_6 ==
          (__prim__int___box__(int___mod__(end_0, int___unbox__(NO_OF_BITS_IN_BYTE())))) in
          (let full_bytes_eq_0 ==
            (byteseq_bytes_equal_until(b1_0, b2_0, int___unbox__(full_bytes_1))) in
            (let cond_0_0 ==
              (__prim__bool___box__(int___gt__(bit_position_6, __prim__int___box__(0)))) in
              (let byte1_3 ==
                ((true && bool___unbox__(cond_0_0) ?
                  __prim__int___box__(PByteSeq___getitem__(b1_0, full_bytes_1)) :
                  null)) in
                (let byte2_3 ==
                  ((true && bool___unbox__(cond_0_0) ?
                    __prim__int___box__(PByteSeq___getitem__(b2_0, full_bytes_1)) :
                    null)) in
                  (true && bool___unbox__(cond_0_0) ?
                    __prim__bool___box__(bool___unbox__(full_bytes_eq_0) &&
                    int___eq__(byte_read_bits(int___unbox__(byte1_3), 0, int___unbox__(bit_position_6)),
                    byte_read_bits(int___unbox__(byte2_3), 0, int___unbox__(bit_position_6)))) :
                    full_bytes_eq_0)))))))))
}

@opaque()
function _lemma_byteseq_equal_prefix_induction(b1_1: Ref, b2_1: Ref, end_1: Ref): Ref
  requires issubtype(typeof(b1_1), PByteSeq())
  requires issubtype(typeof(b2_1), PByteSeq())
  requires issubtype(typeof(end_1), int())
  requires int___le__(__prim__int___box__(PByteSeq___len__(b1_1)), __prim__int___box__(PByteSeq___len__(b2_1)))
  requires int___le__(__prim__int___box__(0), end_1) &&
    int___le__(end_1, __prim__int___box__(int___mul__(PByteSeq___len__(b1_1),
    int___unbox__(NO_OF_BITS_IN_BYTE()))))
  requires bool___unbox__(byteseq_bits_equal_until(b1_1, b2_1, int___unbox__(end_1)))
  ensures issubtype(typeof(result), bool())
  ensures int___ge__(end_1, __prim__int___box__(1)) ==>
    bool___unbox__(byteseq_bits_equal_until(b1_1, b2_1, int___sub__(int___unbox__(end_1),
    1)))
  ensures bool___unbox__(result)
  decreases _
{
  (let cond_2_0 ==
    (__prim__bool___box__(int___eq__(end_1, __prim__int___box__(0)))) in
    (true && bool___unbox__(cond_2_0) ?
      __prim__bool___box__(true) :
      (let induction_end_0 ==
        (__prim__int___box__(int___sub__(int___unbox__(end_1), 1))) in
        (let full_eq_0 ==
          (@reveal()
          (byteseq_bits_equal_until(b1_1, b2_1, int___unbox__(end_1)))) in
          (let full_bytes_2 ==
            (__prim__int___box__(int___floordiv__(int___unbox__(end_1), int___unbox__(NO_OF_BITS_IN_BYTE())))) in
            (let bit_position_7 ==
              (__prim__int___box__(int___mod__(int___unbox__(end_1), int___unbox__(NO_OF_BITS_IN_BYTE())))) in
              (let induction_eq_0 ==
                (@reveal()
                (byteseq_bits_equal_until(b1_1, b2_1, int___unbox__(induction_end_0)))) in
                (let induction_full_bytes_0 ==
                  (__prim__int___box__(int___floordiv__(int___unbox__(induction_end_0),
                  int___unbox__(NO_OF_BITS_IN_BYTE())))) in
                  (let induction_bit_position_0 ==
                    (__prim__int___box__(int___mod__(int___unbox__(induction_end_0),
                    int___unbox__(NO_OF_BITS_IN_BYTE())))) in
                    (let induction_full_bytes_eq_0 ==
                      (byteseq_bytes_equal_until(b1_1, b2_1, int___unbox__(induction_full_bytes_0))) in
                      (let cond_3_0 ==
                        (__prim__bool___box__(int___gt__(bit_position_7, __prim__int___box__(0)) &&
                        int___gt__(induction_bit_position_0, __prim__int___box__(0)))) in
                        (true && bool___unbox__(cond_3_0) ?
                          (asserting (int___eq__(full_bytes_2, induction_full_bytes_0)) in
                            (true && bool___unbox__(cond_3_0) ?
                              (asserting (int___eq__(induction_bit_position_0,
                                __prim__int___box__(int___sub__(int___unbox__(bit_position_7),
                                1)))) in
                                (let induction_b1_0 ==
                                  ((true && bool___unbox__(cond_3_0) ?
                                    __prim__int___box__(PByteSeq___getitem__(b1_1,
                                    full_bytes_2)) :
                                    null)) in
                                  (let induction_b2_0 ==
                                    ((true && bool___unbox__(cond_3_0) ?
                                      __prim__int___box__(PByteSeq___getitem__(b2_1,
                                      full_bytes_2)) :
                                      null)) in
                                    (let lemma_prefix_2 ==
                                      ((true && bool___unbox__(cond_3_0) ?
                                        _lemma_byte_read_bits_equal_prefix(induction_b1_0,
                                        induction_b2_0, __prim__int___box__(0),
                                        bit_position_7) :
                                        null)) in
                                      (let induction_read_b1_0 ==
                                        ((true && bool___unbox__(cond_3_0) ?
                                          byte_read_bits(int___unbox__(induction_b1_0),
                                          0, int___unbox__(induction_bit_position_0)) :
                                          null)) in
                                        (let induction_read_b2_0 ==
                                          ((true &&
                                          bool___unbox__(cond_3_0) ?
                                            byte_read_bits(int___unbox__(induction_b2_0),
                                            0, int___unbox__(induction_bit_position_0)) :
                                            null)) in
                                          (true && bool___unbox__(cond_3_0) ?
                                            __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                            (int___eq__(induction_read_b1_0,
                                            induction_read_b2_0) &&
                                            bool___unbox__(induction_eq_0))) :
                                            (let cond_4_0 ==
                                              (__prim__bool___box__(int___gt__(induction_bit_position_0,
                                              __prim__int___box__(0)))) in
                                              (let induction_b1_1 ==
                                                ((true &&
                                                bool___unbox__(cond_4_0) ?
                                                  __prim__int___box__(PByteSeq___getitem__(b1_1,
                                                  induction_full_bytes_0)) :
                                                  induction_b1_0)) in
                                                (let induction_b2_1 ==
                                                  ((true &&
                                                  bool___unbox__(cond_4_0) ?
                                                    __prim__int___box__(PByteSeq___getitem__(b2_1,
                                                    induction_full_bytes_0)) :
                                                    induction_b2_0)) in
                                                  (true &&
                                                  bool___unbox__(cond_4_0) ?
                                                    __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                                    (int___eq__(induction_b1_1,
                                                    induction_b2_1) &&
                                                    bool___unbox__(induction_eq_0))) :
                                                    __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                                    bool___unbox__(induction_eq_0))))))))))))) :
                              (let induction_b1_0 ==
                                ((true && bool___unbox__(cond_3_0) ?
                                  __prim__int___box__(PByteSeq___getitem__(b1_1,
                                  full_bytes_2)) :
                                  null)) in
                                (let induction_b2_0 ==
                                  ((true && bool___unbox__(cond_3_0) ?
                                    __prim__int___box__(PByteSeq___getitem__(b2_1,
                                    full_bytes_2)) :
                                    null)) in
                                  (let lemma_prefix_2 ==
                                    ((true && bool___unbox__(cond_3_0) ?
                                      _lemma_byte_read_bits_equal_prefix(induction_b1_0,
                                      induction_b2_0, __prim__int___box__(0),
                                      bit_position_7) :
                                      null)) in
                                    (let induction_read_b1_0 ==
                                      ((true && bool___unbox__(cond_3_0) ?
                                        byte_read_bits(int___unbox__(induction_b1_0),
                                        0, int___unbox__(induction_bit_position_0)) :
                                        null)) in
                                      (let induction_read_b2_0 ==
                                        ((true && bool___unbox__(cond_3_0) ?
                                          byte_read_bits(int___unbox__(induction_b2_0),
                                          0, int___unbox__(induction_bit_position_0)) :
                                          null)) in
                                        (true && bool___unbox__(cond_3_0) ?
                                          __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                          (int___eq__(induction_read_b1_0, induction_read_b2_0) &&
                                          bool___unbox__(induction_eq_0))) :
                                          (let cond_4_0 ==
                                            (__prim__bool___box__(int___gt__(induction_bit_position_0,
                                            __prim__int___box__(0)))) in
                                            (let induction_b1_1 ==
                                              ((true &&
                                              bool___unbox__(cond_4_0) ?
                                                __prim__int___box__(PByteSeq___getitem__(b1_1,
                                                induction_full_bytes_0)) :
                                                induction_b1_0)) in
                                              (let induction_b2_1 ==
                                                ((true &&
                                                bool___unbox__(cond_4_0) ?
                                                  __prim__int___box__(PByteSeq___getitem__(b2_1,
                                                  induction_full_bytes_0)) :
                                                  induction_b2_0)) in
                                                (true &&
                                                bool___unbox__(cond_4_0) ?
                                                  __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                                  (int___eq__(induction_b1_1,
                                                  induction_b2_1) &&
                                                  bool___unbox__(induction_eq_0))) :
                                                  __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                                  bool___unbox__(induction_eq_0)))))))))))))) :
                          (true && bool___unbox__(cond_3_0) ?
                            (asserting (int___eq__(induction_bit_position_0,
                              __prim__int___box__(int___sub__(int___unbox__(bit_position_7),
                              1)))) in
                              (let induction_b1_0 ==
                                ((true && bool___unbox__(cond_3_0) ?
                                  __prim__int___box__(PByteSeq___getitem__(b1_1,
                                  full_bytes_2)) :
                                  null)) in
                                (let induction_b2_0 ==
                                  ((true && bool___unbox__(cond_3_0) ?
                                    __prim__int___box__(PByteSeq___getitem__(b2_1,
                                    full_bytes_2)) :
                                    null)) in
                                  (let lemma_prefix_2 ==
                                    ((true && bool___unbox__(cond_3_0) ?
                                      _lemma_byte_read_bits_equal_prefix(induction_b1_0,
                                      induction_b2_0, __prim__int___box__(0),
                                      bit_position_7) :
                                      null)) in
                                    (let induction_read_b1_0 ==
                                      ((true && bool___unbox__(cond_3_0) ?
                                        byte_read_bits(int___unbox__(induction_b1_0),
                                        0, int___unbox__(induction_bit_position_0)) :
                                        null)) in
                                      (let induction_read_b2_0 ==
                                        ((true && bool___unbox__(cond_3_0) ?
                                          byte_read_bits(int___unbox__(induction_b2_0),
                                          0, int___unbox__(induction_bit_position_0)) :
                                          null)) in
                                        (true && bool___unbox__(cond_3_0) ?
                                          __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                          (int___eq__(induction_read_b1_0, induction_read_b2_0) &&
                                          bool___unbox__(induction_eq_0))) :
                                          (let cond_4_0 ==
                                            (__prim__bool___box__(int___gt__(induction_bit_position_0,
                                            __prim__int___box__(0)))) in
                                            (let induction_b1_1 ==
                                              ((true &&
                                              bool___unbox__(cond_4_0) ?
                                                __prim__int___box__(PByteSeq___getitem__(b1_1,
                                                induction_full_bytes_0)) :
                                                induction_b1_0)) in
                                              (let induction_b2_1 ==
                                                ((true &&
                                                bool___unbox__(cond_4_0) ?
                                                  __prim__int___box__(PByteSeq___getitem__(b2_1,
                                                  induction_full_bytes_0)) :
                                                  induction_b2_0)) in
                                                (true &&
                                                bool___unbox__(cond_4_0) ?
                                                  __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                                  (int___eq__(induction_b1_1,
                                                  induction_b2_1) &&
                                                  bool___unbox__(induction_eq_0))) :
                                                  __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                                  bool___unbox__(induction_eq_0))))))))))))) :
                            (let induction_b1_0 ==
                              ((true && bool___unbox__(cond_3_0) ?
                                __prim__int___box__(PByteSeq___getitem__(b1_1,
                                full_bytes_2)) :
                                null)) in
                              (let induction_b2_0 ==
                                ((true && bool___unbox__(cond_3_0) ?
                                  __prim__int___box__(PByteSeq___getitem__(b2_1,
                                  full_bytes_2)) :
                                  null)) in
                                (let lemma_prefix_2 ==
                                  ((true && bool___unbox__(cond_3_0) ?
                                    _lemma_byte_read_bits_equal_prefix(induction_b1_0,
                                    induction_b2_0, __prim__int___box__(0),
                                    bit_position_7) :
                                    null)) in
                                  (let induction_read_b1_0 ==
                                    ((true && bool___unbox__(cond_3_0) ?
                                      byte_read_bits(int___unbox__(induction_b1_0),
                                      0, int___unbox__(induction_bit_position_0)) :
                                      null)) in
                                    (let induction_read_b2_0 ==
                                      ((true && bool___unbox__(cond_3_0) ?
                                        byte_read_bits(int___unbox__(induction_b2_0),
                                        0, int___unbox__(induction_bit_position_0)) :
                                        null)) in
                                      (true && bool___unbox__(cond_3_0) ?
                                        __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                        (int___eq__(induction_read_b1_0, induction_read_b2_0) &&
                                        bool___unbox__(induction_eq_0))) :
                                        (let cond_4_0 ==
                                          (__prim__bool___box__(int___gt__(induction_bit_position_0,
                                          __prim__int___box__(0)))) in
                                          (let induction_b1_1 ==
                                            ((true &&
                                            bool___unbox__(cond_4_0) ?
                                              __prim__int___box__(PByteSeq___getitem__(b1_1,
                                              induction_full_bytes_0)) :
                                              induction_b1_0)) in
                                            (let induction_b2_1 ==
                                              ((true &&
                                              bool___unbox__(cond_4_0) ?
                                                __prim__int___box__(PByteSeq___getitem__(b2_1,
                                                induction_full_bytes_0)) :
                                                induction_b2_0)) in
                                              (true &&
                                              bool___unbox__(cond_4_0) ?
                                                __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                                (int___eq__(induction_b1_1,
                                                induction_b2_1) &&
                                                bool___unbox__(induction_eq_0))) :
                                                __prim__bool___box__(bool___unbox__(induction_full_bytes_eq_0) &&
                                                bool___unbox__(induction_eq_0)))))))))))))))))))))))))
}

@opaque()
function byte_read_bit(byte: Int, position_0: Int): Ref
  requires int___le__(__prim__int___box__(0), __prim__int___box__(byte)) &&
    int___le__(__prim__int___box__(byte), __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), __prim__int___box__(position_0)) &&
    int___lt__(__prim__int___box__(position_0), NO_OF_BITS_IN_BYTE())
  ensures issubtype(typeof(result), bool())
  decreases _
{
  __prim__bool___box__(int___bool__(__prim__int___box__(int___mod__(int___unbox__(int___rshift__(__prim__int___box__(byte),
  __prim__int___box__(int___sub__(7, position_0)))), 2))))
}

@opaque()
function byte_read_bits(byte_0: Int, position_1: Int, length: Int): Ref
  requires int___le__(__prim__int___box__(0), __prim__int___box__(byte_0)) &&
    int___le__(__prim__int___box__(byte_0), __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), __prim__int___box__(length)) &&
    int___le__(__prim__int___box__(length), NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), __prim__int___box__(position_1)) &&
    int___le__(__prim__int___box__(int___add__(position_1, length)), NO_OF_BITS_IN_BYTE())
  ensures issubtype(typeof(result), int())
  ensures int___le__(__prim__int___box__(0), result) &&
    int___lt__(result, int___lshift__(__prim__int___box__(1), __prim__int___box__(length)))
  decreases _
{
  __prim__int___box__(int___mod__(int___unbox__(int___rshift__(__prim__int___box__(byte_0),
  __prim__int___box__(int___sub__(int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
  position_1), length)))), int___unbox__(int___lshift__(__prim__int___box__(1),
  __prim__int___box__(length)))))
}

@opaque()
function _lemma_byte_read_bit_equal(byte_1: Ref, position_2: Ref): Ref
  requires issubtype(typeof(byte_1), int())
  requires issubtype(typeof(position_2), int())
  requires int___le__(__prim__int___box__(0), byte_1) &&
    int___le__(byte_1, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), position_2) &&
    int___lt__(position_2, NO_OF_BITS_IN_BYTE())
  ensures issubtype(typeof(result), bool())
  ensures int___eq__(int___int__(byte_read_bit(int___unbox__(byte_1), int___unbox__(position_2))),
    byte_read_bits(int___unbox__(byte_1), int___unbox__(position_2), 1))
  ensures bool___unbox__(result)
{
  (let single_5 ==
    (@reveal()
    (byte_read_bit(int___unbox__(byte_1), int___unbox__(position_2)))) in
    (let multiple_0 ==
      (@reveal()
      (byte_read_bits(int___unbox__(byte_1), int___unbox__(position_2), 1))) in
      __prim__bool___box__(int___eq__(int___int__(single_5), multiple_0))))
}

@opaque()
function _lemma_byte_prefix_implies_read_bit(byte1_0: Ref, byte2_0: Ref, prefix_length: Ref,
  position_3: Ref): Ref
  requires issubtype(typeof(byte1_0), int())
  requires issubtype(typeof(byte2_0), int())
  requires issubtype(typeof(prefix_length), int())
  requires issubtype(typeof(position_3), int())
  requires int___le__(__prim__int___box__(0), byte1_0) &&
    int___le__(byte1_0, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), byte2_0) &&
    int___le__(byte2_0, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), prefix_length) &&
    int___le__(prefix_length, NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), position_3) &&
    int___lt__(position_3, prefix_length)
  requires int___eq__(byte_read_bits(int___unbox__(byte1_0), 0, int___unbox__(prefix_length)),
    byte_read_bits(int___unbox__(byte2_0), 0, int___unbox__(prefix_length)))
  ensures issubtype(typeof(result), bool())
  ensures bool___eq__(byte_read_bit(int___unbox__(byte1_0), int___unbox__(position_3)),
    byte_read_bit(int___unbox__(byte2_0), int___unbox__(position_3)))
  ensures bool___unbox__(result)
  decreases _
{
  (let b1_read_0 ==
    (@reveal()
    (byte_read_bits(int___unbox__(byte1_0), 0, int___unbox__(prefix_length)))) in
    (let b2_read_0 ==
      (@reveal()
      (byte_read_bits(int___unbox__(byte2_0), 0, int___unbox__(prefix_length)))) in
      (asserting (int___eq__(b1_read_0, b2_read_0)) in
        (let b1_bit_0 ==
          (@reveal()
          (byte_read_bit(int___unbox__(byte1_0), int___unbox__(position_3)))) in
          (let b2_bit_0 ==
            (@reveal()
            (byte_read_bit(int___unbox__(byte2_0), int___unbox__(position_3)))) in
            __prim__bool___box__(bool___eq__(b1_bit_0, b2_bit_0)))))))
}

@opaque()
function _lemma_byte_read_bits_induction(byte_2: Ref, position_4: Ref, length_0: Ref): Ref
  requires issubtype(typeof(byte_2), int())
  requires issubtype(typeof(position_4), int())
  requires issubtype(typeof(length_0), int())
  requires int___le__(__prim__int___box__(0), byte_2) &&
    int___le__(byte_2, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), position_4) &&
    int___le__(position_4, NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), length_0) &&
    int___le__(__prim__int___box__(int___add__(int___unbox__(length_0), int___unbox__(position_4))),
    NO_OF_BITS_IN_BYTE())
  ensures issubtype(typeof(result), bool())
  ensures int___eq__(length_0, __prim__int___box__(0)) ==>
    int___eq__(byte_read_bits(int___unbox__(byte_2), int___unbox__(position_4),
    int___unbox__(length_0)), __prim__int___box__(0))
  ensures int___ge__(length_0, __prim__int___box__(1)) ==>
    int___eq__(byte_read_bits(int___unbox__(byte_2), int___unbox__(position_4),
    int___unbox__(length_0)), __prim__int___box__(int___add__(int___unbox__(int___lshift__(byte_read_bits(int___unbox__(byte_2),
    int___unbox__(position_4), int___sub__(int___unbox__(length_0), 1)), __prim__int___box__(1))),
    int___unbox__(byte_read_bits(int___unbox__(byte_2), int___sub__(int___add__(int___unbox__(position_4),
    int___unbox__(length_0)), 1), 1)))))
  ensures bool___unbox__(result)
  decreases int___unbox__(length_0)
{
  (let cond_5_0 ==
    (__prim__bool___box__(int___eq__(length_0, __prim__int___box__(0)))) in
    (true && bool___unbox__(cond_5_0) ?
      __prim__bool___box__(true) :
      (let full_2 ==
        (@reveal()
        (byte_read_bits(int___unbox__(byte_2), int___unbox__(position_4), int___unbox__(length_0)))) in
        (let prefix_2 ==
          (int___lshift__(@reveal()
          (byte_read_bits(int___unbox__(byte_2), int___unbox__(position_4),
          int___sub__(int___unbox__(length_0), 1))), __prim__int___box__(1))) in
          (let single_6 ==
            (@reveal()
            (byte_read_bits(int___unbox__(byte_2), int___sub__(int___add__(int___unbox__(position_4),
            int___unbox__(length_0)), 1), 1))) in
            (let inner_0 ==
              (_lemma_byte_read_bits_induction(byte_2, position_4, __prim__int___box__(int___sub__(int___unbox__(length_0),
              1)))) in
              __prim__bool___box__(bool___unbox__(inner_0) &&
              int___eq__(full_2, __prim__int___box__(int___add__(int___unbox__(prefix_2),
              int___unbox__(single_6)))))))))))
}

@opaque()
function _lemma_byte_read_bits_equal_prefix(byte1_1: Ref, byte2_1: Ref, position_5: Ref,
  length_1: Ref): Ref
  requires issubtype(typeof(byte1_1), int())
  requires issubtype(typeof(byte2_1), int())
  requires issubtype(typeof(position_5), int())
  requires issubtype(typeof(length_1), int())
  requires int___le__(__prim__int___box__(0), byte1_1) &&
    int___le__(byte1_1, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), byte2_1) &&
    int___le__(byte2_1, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), position_5) &&
    int___le__(position_5, NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), length_1) &&
    int___le__(__prim__int___box__(int___add__(int___unbox__(length_1), int___unbox__(position_5))),
    NO_OF_BITS_IN_BYTE())
  requires int___eq__(byte_read_bits(int___unbox__(byte1_1), int___unbox__(position_5),
    int___unbox__(length_1)), byte_read_bits(int___unbox__(byte2_1), int___unbox__(position_5),
    int___unbox__(length_1)))
  ensures issubtype(typeof(result), bool())
  ensures int___gt__(length_1, __prim__int___box__(0)) ==>
    int___eq__(byte_read_bits(int___unbox__(byte1_1), int___unbox__(position_5),
    int___sub__(int___unbox__(length_1), 1)), byte_read_bits(int___unbox__(byte2_1),
    int___unbox__(position_5), int___sub__(int___unbox__(length_1), 1)))
  ensures bool___unbox__(result)
  decreases _
{
  (let cond_6_0 ==
    (__prim__bool___box__(int___eq__(length_1, __prim__int___box__(0)))) in
    (true && bool___unbox__(cond_6_0) ?
      __prim__bool___box__(true) :
      (let byte1_full_0 ==
        (byte_read_bits(int___unbox__(byte1_1), int___unbox__(position_5), int___unbox__(length_1))) in
        (let byte2_full_0 ==
          (byte_read_bits(int___unbox__(byte2_1), int___unbox__(position_5),
          int___unbox__(length_1))) in
          (asserting (int___eq__(byte1_full_0, byte2_full_0)) in
            (let byte1_induction_lemma_0 ==
              (_lemma_byte_read_bits_induction(byte1_1, position_5, length_1)) in
              (let byte2_induction_lemma_0 ==
                (_lemma_byte_read_bits_induction(byte2_1, position_5, length_1)) in
                (asserting (int___eq__(byte_read_bits(int___unbox__(byte1_1),
                  int___sub__(int___add__(int___unbox__(position_5), int___unbox__(length_1)),
                  1), 1), byte_read_bits(int___unbox__(byte1_1), int___sub__(int___add__(int___unbox__(position_5),
                  int___unbox__(length_1)), 1), 1))) in
                  (let byte1_part_0 ==
                    (byte_read_bits(int___unbox__(byte1_1), int___unbox__(position_5),
                    int___sub__(int___unbox__(length_1), 1))) in
                    (let byte2_part_0 ==
                      (byte_read_bits(int___unbox__(byte2_1), int___unbox__(position_5),
                      int___sub__(int___unbox__(length_1), 1))) in
                      __prim__bool___box__(int___eq__(byte1_part_0, byte2_part_0))))))))))))
}

@opaque()
function byteseq_read_bit(byteseq: Ref, position_6: Int): Ref
  requires issubtype(typeof(byteseq), PByteSeq())
  requires int___le__(__prim__int___box__(0), __prim__int___box__(position_6)) &&
    int___lt__(__prim__int___box__(position_6), __prim__int___box__(int___mul__(PByteSeq___len__(byteseq),
    int___unbox__(NO_OF_BITS_IN_BYTE()))))
  ensures issubtype(typeof(result), bool())
  decreases _
{
  (let byte_position_4 ==
    (__prim__int___box__(int___floordiv__(position_6, int___unbox__(NO_OF_BITS_IN_BYTE())))) in
    (let bit_position_8 ==
      (__prim__int___box__(int___mod__(position_6, int___unbox__(NO_OF_BITS_IN_BYTE())))) in
      byte_read_bit(PByteSeq___getitem__(byteseq, byte_position_4), int___unbox__(bit_position_8))))
}

@opaque()
function byteseq_read_bits(byteseq_0: Ref, position_7: Int, length_2: Int): Ref
  requires issubtype(typeof(byteseq_0), PByteSeq())
  requires int___le__(__prim__int___box__(0), __prim__int___box__(length_2)) &&
    int___le__(__prim__int___box__(length_2), NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), __prim__int___box__(position_7)) &&
    int___le__(__prim__int___box__(int___add__(position_7, length_2)), __prim__int___box__(int___mul__(PByteSeq___len__(byteseq_0),
    int___unbox__(NO_OF_BITS_IN_BYTE()))))
  ensures issubtype(typeof(result), int())
  ensures int___le__(__prim__int___box__(0), result) &&
    int___lt__(result, int___lshift__(__prim__int___box__(1), __prim__int___box__(length_2)))
  decreases length_2
{
  (let cond_7_0 ==
    (__prim__bool___box__(int___eq__(__prim__int___box__(length_2), __prim__int___box__(0)))) in
    (true && bool___unbox__(cond_7_0) ?
      __prim__int___box__(0) :
      (let prefix_3 ==
        (int___lshift__(byteseq_read_bits(byteseq_0, position_7, int___sub__(length_2,
        1)), __prim__int___box__(1))) in
        (let single_7 ==
          (byteseq_read_bit(byteseq_0, int___sub__(int___add__(position_7, length_2),
          1))) in
          __prim__int___box__(int___add__(int___unbox__(prefix_3), int___unbox__(single_7)))))))
}

@opaque()
function _lemma_byteseq_read_bits_equal(byteseq_1: Ref, position_8: Ref): Ref
  requires issubtype(typeof(byteseq_1), PByteSeq())
  requires issubtype(typeof(position_8), int())
  requires int___le__(__prim__int___box__(0), position_8) &&
    int___le__(__prim__int___box__(int___add__(int___unbox__(position_8), 1)),
    __prim__int___box__(int___mul__(PByteSeq___len__(byteseq_1), int___unbox__(NO_OF_BITS_IN_BYTE()))))
  ensures issubtype(typeof(result), bool())
  ensures int___eq__(byteseq_read_bits(byteseq_1, int___unbox__(position_8),
    1), int___int__(byteseq_read_bit(byteseq_1, int___unbox__(position_8))))
  ensures bool___unbox__(result)
  decreases _
{
  (let repeated_1 ==
    (@reveal()
    (byteseq_read_bits(byteseq_1, int___unbox__(position_8), 1))) in
    (let single_8 ==
      (byteseq_read_bit(byteseq_1, int___unbox__(position_8))) in
      __prim__bool___box__(int___eq__(repeated_1, single_8))))
}

@opaque()
function _lemma_byteseq_read_bits_induction_lsb(byteseq_2: Ref, position_9: Ref,
  length_3: Ref): Ref
  requires issubtype(typeof(byteseq_2), PByteSeq())
  requires issubtype(typeof(position_9), int())
  requires issubtype(typeof(length_3), int())
  requires int___le__(__prim__int___box__(0), length_3) &&
    int___le__(length_3, NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), position_9) &&
    int___le__(__prim__int___box__(int___add__(int___unbox__(position_9), int___unbox__(length_3))),
    __prim__int___box__(int___mul__(PByteSeq___len__(byteseq_2), int___unbox__(NO_OF_BITS_IN_BYTE()))))
  ensures issubtype(typeof(result), bool())
  ensures int___ge__(length_3, __prim__int___box__(1)) ==>
    int___eq__(byteseq_read_bits(byteseq_2, int___unbox__(position_9), int___unbox__(length_3)),
    __prim__int___box__(int___add__(int___unbox__(int___lshift__(byteseq_read_bits(byteseq_2,
    int___unbox__(position_9), int___sub__(int___unbox__(length_3), 1)), __prim__int___box__(1))),
    int___unbox__(byteseq_read_bits(byteseq_2, int___sub__(int___add__(int___unbox__(position_9),
    int___unbox__(length_3)), 1), 1)))))
  ensures bool___unbox__(result)
  decreases int___unbox__(length_3)
{
  (let cond_8_0 ==
    (__prim__bool___box__(int___eq__(length_3, __prim__int___box__(0)))) in
    (true && bool___unbox__(cond_8_0) ?
      __prim__bool___box__(true) :
      (let full_3 ==
        (@reveal()
        (byteseq_read_bits(byteseq_2, int___unbox__(position_9), int___unbox__(length_3)))) in
        (let prefix_4 ==
          (int___lshift__(@reveal()
          (byteseq_read_bits(byteseq_2, int___unbox__(position_9), int___sub__(int___unbox__(length_3),
          1))), __prim__int___box__(1))) in
          (let single_9 ==
            (@reveal()
            (byteseq_read_bits(byteseq_2, int___sub__(int___add__(int___unbox__(position_9),
            int___unbox__(length_3)), 1), 1))) in
            (let eq_lemma_0 ==
              (_lemma_byteseq_read_bits_equal(byteseq_2, __prim__int___box__(int___sub__(int___add__(int___unbox__(position_9),
              int___unbox__(length_3)), 1)))) in
              (let inner_lemma_0 ==
                (_lemma_byteseq_read_bits_induction_lsb(byteseq_2, position_9,
                __prim__int___box__(int___sub__(int___unbox__(length_3), 1)))) in
                __prim__bool___box__(bool___unbox__(eq_lemma_0) &&
                (bool___unbox__(inner_lemma_0) &&
                int___eq__(full_3, __prim__int___box__(int___add__(int___unbox__(prefix_4),
                int___unbox__(single_9)))))))))))))
}

@opaque()
function byte_set_bit(byte_3: Int, bit: Ref, position_10: Int): Ref
  requires issubtype(typeof(bit), bool())
  requires int___le__(__prim__int___box__(0), __prim__int___box__(byte_3)) &&
    int___le__(__prim__int___box__(byte_3), __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), __prim__int___box__(position_10)) &&
    int___lt__(__prim__int___box__(position_10), NO_OF_BITS_IN_BYTE())
  ensures issubtype(typeof(result), int())
  ensures int___le__(__prim__int___box__(0), result) &&
    int___le__(result, __prim__int___box__(255))
  decreases _
{
  (let cond_9_0 ==
    (bit) in
    (true && bool___unbox__(cond_9_0) ?
      int___or__(__prim__int___box__(byte_3), int___lshift__(__prim__int___box__(1),
      __prim__int___box__(int___sub__(7, position_10)))) :
      int___and__(__prim__int___box__(byte_3), int___invert__(int___lshift__(__prim__int___box__(1),
      __prim__int___box__(int___sub__(7, position_10)))))))
}

@opaque()
function byte_set_bits(byte_4: Int, value_0: Int, position_11: Int, length_4: Int): Ref
  requires int___le__(__prim__int___box__(0), __prim__int___box__(byte_4)) &&
    int___le__(__prim__int___box__(byte_4), __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), __prim__int___box__(length_4)) &&
    int___le__(__prim__int___box__(length_4), NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), __prim__int___box__(position_11)) &&
    int___le__(__prim__int___box__(int___add__(position_11, length_4)), NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), __prim__int___box__(value_0)) &&
    int___lt__(__prim__int___box__(value_0), int___lshift__(__prim__int___box__(1),
    __prim__int___box__(length_4)))
  ensures issubtype(typeof(result), int())
  ensures int___le__(__prim__int___box__(0), result) &&
    int___le__(result, __prim__int___box__(255))
{
  (let upper_1 ==
    (int___lshift__(byte_read_bits(byte_4, 0, position_11), __prim__int___box__(int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
    position_11)))) in
    (let middle_0 ==
      (int___lshift__(__prim__int___box__(value_0), __prim__int___box__(int___sub__(int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
      position_11), length_4)))) in
      (let lower_1 ==
        (__prim__int___box__(int___mod__(byte_4, int___unbox__(int___lshift__(__prim__int___box__(1),
        __prim__int___box__(int___sub__(int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
        position_11), length_4))))))) in
        __prim__int___box__(int___add__(int___add__(int___unbox__(upper_1),
        int___unbox__(middle_0)), int___unbox__(lower_1))))))
}

@opaque()
function __lemma_byte_set_bit_true_equal(byte_5: Ref, position_12: Ref): Ref
  requires issubtype(typeof(byte_5), int())
  requires issubtype(typeof(position_12), int())
  requires int___le__(__prim__int___box__(0), byte_5) &&
    int___le__(byte_5, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), position_12) &&
    int___lt__(position_12, NO_OF_BITS_IN_BYTE())
  ensures issubtype(typeof(result), bool())
  ensures int___eq__(byte_set_bit(int___unbox__(byte_5), __prim__bool___box__(true),
    int___unbox__(position_12)), byte_set_bits(int___unbox__(byte_5), int___unbox__(__prim__bool___box__(true)),
    int___unbox__(position_12), 1))
  ensures bool___unbox__(result)
{
  (let new_byte_a_1 ==
    (@reveal()
    (byte_set_bit(int___unbox__(byte_5), __prim__bool___box__(true), int___unbox__(position_12)))) in
    (let new_byte_b_1 ==
      (@reveal()
      (byte_set_bits(int___unbox__(byte_5), int___unbox__(__prim__bool___box__(true)),
      int___unbox__(position_12), 1))) in
      (let upper_b_1 ==
        (@reveal()
        (byte_read_bits(int___unbox__(byte_5), 0, int___unbox__(position_12)))) in
        __prim__bool___box__(int___eq__(new_byte_a_1, new_byte_b_1)))))
}

@opaque()
function __lemma_byte_set_bit_false_equal(byte_6: Ref, position_13: Ref): Ref
  requires issubtype(typeof(byte_6), int())
  requires issubtype(typeof(position_13), int())
  requires int___le__(__prim__int___box__(0), byte_6) &&
    int___le__(byte_6, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), position_13) &&
    int___lt__(position_13, NO_OF_BITS_IN_BYTE())
  ensures issubtype(typeof(result), bool())
  ensures int___eq__(byte_set_bit(int___unbox__(byte_6), __prim__bool___box__(false),
    int___unbox__(position_13)), byte_set_bits(int___unbox__(byte_6), int___unbox__(__prim__bool___box__(false)),
    int___unbox__(position_13), 1))
  ensures bool___unbox__(result)
{
  (let new_byte_a_2 ==
    (@reveal()
    (byte_set_bit(int___unbox__(byte_6), __prim__bool___box__(false), int___unbox__(position_13)))) in
    (let new_byte_b_2 ==
      (@reveal()
      (byte_set_bits(int___unbox__(byte_6), int___unbox__(__prim__bool___box__(false)),
      int___unbox__(position_13), 1))) in
      (let upper_b_2 ==
        (@reveal()
        (byte_read_bits(int___unbox__(byte_6), 0, int___unbox__(position_13)))) in
        __prim__bool___box__(int___eq__(new_byte_a_2, new_byte_b_2)))))
}

@opaque()
function _lemma_byte_set_bit_equal(byte_7: Ref, bit_0: Ref, position_14: Ref): Ref
  requires issubtype(typeof(byte_7), int())
  requires issubtype(typeof(bit_0), bool())
  requires issubtype(typeof(position_14), int())
  requires int___le__(__prim__int___box__(0), byte_7) &&
    int___le__(byte_7, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), position_14) &&
    int___lt__(position_14, NO_OF_BITS_IN_BYTE())
  ensures issubtype(typeof(result), bool())
  ensures int___eq__(byte_set_bit(int___unbox__(byte_7), bit_0, int___unbox__(position_14)),
    byte_set_bits(int___unbox__(byte_7), int___unbox__(bit_0), int___unbox__(position_14),
    1))
  ensures bool___unbox__(result)
{
  (let cond_10_0 ==
    (bit_0) in
    (true && bool___unbox__(cond_10_0) ?
      __lemma_byte_set_bit_true_equal(byte_7, position_14) :
      __lemma_byte_set_bit_false_equal(byte_7, position_14)))
}

@opaque()
function __lemma_byte_set_bits_prefix(byte_8: Ref, value_1: Ref, position_15: Ref,
  length_5: Ref): Ref
  requires issubtype(typeof(byte_8), int())
  requires issubtype(typeof(value_1), int())
  requires issubtype(typeof(position_15), int())
  requires issubtype(typeof(length_5), int())
  requires int___le__(__prim__int___box__(0), byte_8) &&
    int___le__(byte_8, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), length_5) &&
    int___le__(length_5, NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), position_15) &&
    int___le__(__prim__int___box__(int___add__(int___unbox__(position_15), int___unbox__(length_5))),
    NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), value_1) &&
    int___lt__(value_1, int___lshift__(__prim__int___box__(1), length_5))
  ensures issubtype(typeof(result), bool())
  ensures int___eq__(byte_read_bits(int___unbox__(byte_set_bits(int___unbox__(byte_8),
    int___unbox__(value_1), int___unbox__(position_15), int___unbox__(length_5))),
    0, int___unbox__(position_15)), byte_read_bits(int___unbox__(byte_8), 0,
    int___unbox__(position_15)))
  ensures bool___unbox__(result)
{
  (let new_byte_4 ==
    (@reveal()
    (byte_set_bits(int___unbox__(byte_8), int___unbox__(value_1), int___unbox__(position_15),
    int___unbox__(length_5)))) in
    (let new_upper_0 ==
      (@reveal()
      (byte_read_bits(int___unbox__(new_byte_4), 0, int___unbox__(position_15)))) in
      (let upper_2 ==
        (@reveal()
        (byte_read_bits(int___unbox__(byte_8), 0, int___unbox__(position_15)))) in
        __prim__bool___box__(int___eq__(new_upper_0, upper_2)))))
}

@opaque()
function __lemma_byte_set_bits_value(byte_9: Ref, value_2: Ref, position_16: Ref,
  length_6: Ref): Ref
  requires issubtype(typeof(byte_9), int())
  requires issubtype(typeof(value_2), int())
  requires issubtype(typeof(position_16), int())
  requires issubtype(typeof(length_6), int())
  requires int___le__(__prim__int___box__(0), byte_9) &&
    int___le__(byte_9, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), length_6) &&
    int___le__(length_6, NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), position_16) &&
    int___le__(__prim__int___box__(int___add__(int___unbox__(position_16), int___unbox__(length_6))),
    NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), value_2) &&
    int___lt__(value_2, int___lshift__(__prim__int___box__(1), length_6))
  ensures issubtype(typeof(result), bool())
  ensures int___eq__(byte_read_bits(int___unbox__(byte_set_bits(int___unbox__(byte_9),
    int___unbox__(value_2), int___unbox__(position_16), int___unbox__(length_6))),
    int___unbox__(position_16), int___unbox__(length_6)), value_2)
  ensures bool___unbox__(result)
{
  (let new_byte_5 ==
    (@reveal()
    (byte_set_bits(int___unbox__(byte_9), int___unbox__(value_2), int___unbox__(position_16),
    int___unbox__(length_6)))) in
    (let written_value_0 ==
      (@reveal()
      (byte_read_bits(int___unbox__(new_byte_5), int___unbox__(position_16),
      int___unbox__(length_6)))) in
      __prim__bool___box__(int___eq__(written_value_0, value_2))))
}

@opaque()
function __lemma_byte_set_bits_suffix(byte_10: Ref, value_3: Ref, position_17: Ref,
  length_7: Ref): Ref
  requires issubtype(typeof(byte_10), int())
  requires issubtype(typeof(value_3), int())
  requires issubtype(typeof(position_17), int())
  requires issubtype(typeof(length_7), int())
  requires int___le__(__prim__int___box__(0), byte_10) &&
    int___le__(byte_10, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), length_7) &&
    int___le__(length_7, NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), position_17) &&
    int___le__(__prim__int___box__(int___add__(int___unbox__(position_17), int___unbox__(length_7))),
    NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), value_3) &&
    int___lt__(value_3, int___lshift__(__prim__int___box__(1), length_7))
  ensures issubtype(typeof(result), bool())
  ensures int___eq__(byte_read_bits(int___unbox__(byte_set_bits(int___unbox__(byte_10),
    int___unbox__(value_3), int___unbox__(position_17), int___unbox__(length_7))),
    int___add__(int___unbox__(position_17), int___unbox__(length_7)), int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
    int___add__(int___unbox__(position_17), int___unbox__(length_7)))), byte_read_bits(int___unbox__(byte_10),
    int___add__(int___unbox__(position_17), int___unbox__(length_7)), int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
    int___add__(int___unbox__(position_17), int___unbox__(length_7)))))
  ensures bool___unbox__(result)
{
  (let lower_length_0 ==
    (__prim__int___box__(int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()), int___add__(int___unbox__(position_17),
    int___unbox__(length_7))))) in
    (let new_byte_6 ==
      (@reveal()
      (byte_set_bits(int___unbox__(byte_10), int___unbox__(value_3), int___unbox__(position_17),
      int___unbox__(length_7)))) in
      (let new_lower_0 ==
        (@reveal()
        (byte_read_bits(int___unbox__(new_byte_6), int___add__(int___unbox__(position_17),
        int___unbox__(length_7)), int___unbox__(lower_length_0)))) in
        (let lower_2 ==
          (@reveal()
          (byte_read_bits(int___unbox__(byte_10), int___add__(int___unbox__(position_17),
          int___unbox__(length_7)), int___unbox__(lower_length_0)))) in
          __prim__bool___box__(int___eq__(new_lower_0, lower_2))))))
}

@opaque()
function _lemma_byte_set_bits(byte_11: Ref, value_4: Ref, position_18: Ref,
  length_8: Ref): Ref
  requires issubtype(typeof(byte_11), int())
  requires issubtype(typeof(value_4), int())
  requires issubtype(typeof(position_18), int())
  requires issubtype(typeof(length_8), int())
  requires int___le__(__prim__int___box__(0), byte_11) &&
    int___le__(byte_11, __prim__int___box__(255))
  requires int___le__(__prim__int___box__(0), length_8) &&
    int___le__(length_8, NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), position_18) &&
    int___le__(__prim__int___box__(int___add__(int___unbox__(position_18), int___unbox__(length_8))),
    NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), value_4) &&
    int___lt__(value_4, int___lshift__(__prim__int___box__(1), length_8))
  ensures issubtype(typeof(result), bool())
  ensures int___eq__(byte_read_bits(int___unbox__(byte_set_bits(int___unbox__(byte_11),
    int___unbox__(value_4), int___unbox__(position_18), int___unbox__(length_8))),
    int___unbox__(position_18), int___unbox__(length_8)), value_4)
  ensures int___eq__(byte_read_bits(int___unbox__(byte_set_bits(int___unbox__(byte_11),
    int___unbox__(value_4), int___unbox__(position_18), int___unbox__(length_8))),
    0, int___unbox__(position_18)), byte_read_bits(int___unbox__(byte_11), 0,
    int___unbox__(position_18)))
  ensures int___eq__(byte_read_bits(int___unbox__(byte_set_bits(int___unbox__(byte_11),
    int___unbox__(value_4), int___unbox__(position_18), int___unbox__(length_8))),
    int___add__(int___unbox__(position_18), int___unbox__(length_8)), int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
    int___add__(int___unbox__(position_18), int___unbox__(length_8)))), byte_read_bits(int___unbox__(byte_11),
    int___add__(int___unbox__(position_18), int___unbox__(length_8)), int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
    int___add__(int___unbox__(position_18), int___unbox__(length_8)))))
  ensures bool___unbox__(result)
{
  (let lemma_prefix_3 ==
    (__lemma_byte_set_bits_prefix(byte_11, value_4, position_18, length_8)) in
    (let lemma_value_0 ==
      (__lemma_byte_set_bits_value(byte_11, value_4, position_18, length_8)) in
      (let lemma_suffix_0 ==
        (__lemma_byte_set_bits_suffix(byte_11, value_4, position_18, length_8)) in
        __prim__bool___box__(bool___unbox__(lemma_prefix_3) &&
        (bool___unbox__(lemma_value_0) && bool___unbox__(lemma_suffix_0))))))
}

@opaque()
function byteseq_set_bit(byteseq_3: Ref, bit_1: Ref, position_19: Int): Ref
  requires issubtype(typeof(byteseq_3), PByteSeq())
  requires issubtype(typeof(bit_1), bool())
  requires int___le__(__prim__int___box__(0), __prim__int___box__(position_19)) &&
    int___lt__(__prim__int___box__(position_19), __prim__int___box__(int___mul__(PByteSeq___len__(byteseq_3),
    int___unbox__(NO_OF_BITS_IN_BYTE()))))
  ensures issubtype(typeof(result), PByteSeq())
  ensures int___eq__(__prim__int___box__(PByteSeq___len__(byteseq_3)), __prim__int___box__(PByteSeq___len__(result)))
  decreases _
{
  (let byte_position_5 ==
    (__prim__int___box__(int___floordiv__(position_19, int___unbox__(NO_OF_BITS_IN_BYTE())))) in
    (let bit_position_9 ==
      (__prim__int___box__(int___mod__(position_19, int___unbox__(NO_OF_BITS_IN_BYTE())))) in
      PByteSeq_update(byteseq_3, int___unbox__(byte_position_5), int___unbox__(byte_set_bit(PByteSeq___getitem__(byteseq_3,
      byte_position_5), bit_1, int___unbox__(bit_position_9))))))
}

@opaque()
function __lemma_byteseq_set_bit_value(byteseq_4: Ref, bit_2: Ref, position_20: Ref): Ref
  requires issubtype(typeof(byteseq_4), PByteSeq())
  requires issubtype(typeof(bit_2), bool())
  requires issubtype(typeof(position_20), int())
  requires int___le__(__prim__int___box__(0), position_20) &&
    int___lt__(position_20, __prim__int___box__(int___mul__(PByteSeq___len__(byteseq_4),
    int___unbox__(NO_OF_BITS_IN_BYTE()))))
  ensures issubtype(typeof(result), bool())
  ensures int___eq__(byteseq_read_bits(byteseq_set_bit(byteseq_4, bit_2, int___unbox__(position_20)),
    int___unbox__(position_20), 1), int___int__(bit_2))
  ensures bool___unbox__(result)
{
  (let byte_position_6 ==
    (__prim__int___box__(int___floordiv__(int___unbox__(position_20), int___unbox__(NO_OF_BITS_IN_BYTE())))) in
    (let bit_position_10 ==
      (__prim__int___box__(int___mod__(int___unbox__(position_20), int___unbox__(NO_OF_BITS_IN_BYTE())))) in
      (let byte_14 ==
        (__prim__int___box__(PByteSeq___getitem__(byteseq_4, byte_position_6))) in
        (let new_seq_2 ==
          (@reveal()
          (byteseq_set_bit(byteseq_4, bit_2, int___unbox__(position_20)))) in
          (let new_byte_7 ==
            (__prim__int___box__(PByteSeq___getitem__(new_seq_2, byte_position_6))) in
            (let lemma_byte_equal_1 ==
              (_lemma_byte_set_bit_equal(byte_14, bit_2, bit_position_10)) in
              (let lemma_byte_1 ==
                (__lemma_byte_set_bits_value(byte_14, bit_2, bit_position_10,
                __prim__int___box__(1))) in
                (let from_bits_read_0 ==
                  (__prim__bool___box__(int___bool__(byte_read_bits(int___unbox__(new_byte_7),
                  int___unbox__(bit_position_10), 1)))) in
                  (let lemma_byte_read_0 ==
                    (_lemma_byte_read_bit_equal(new_byte_7, bit_position_10)) in
                    (let from_bit_read_0 ==
                      (byte_read_bit(int___unbox__(new_byte_7), int___unbox__(bit_position_10))) in
                      (let from_seq_bit_0 ==
                        (@reveal()
                        (byteseq_read_bit(new_seq_2, int___unbox__(position_20)))) in
                        (let lemma_seq_read_0 ==
                          (_lemma_byteseq_read_bits_equal(new_seq_2, position_20)) in
                          __prim__bool___box__(bool___eq__(bit_2, from_bits_read_0) &&
                          (bool___eq__(from_bits_read_0, from_bit_read_0) &&
                          bool___eq__(from_bit_read_0, from_seq_bit_0)))))))))))))))
}

@opaque()
function __lemma_byteseq_set_bit_prefix(byteseq_5: Ref, bit_3: Ref, position_21: Ref): Ref
  requires issubtype(typeof(byteseq_5), PByteSeq())
  requires issubtype(typeof(bit_3), bool())
  requires issubtype(typeof(position_21), int())
  requires int___le__(__prim__int___box__(0), position_21) &&
    int___lt__(position_21, __prim__int___box__(int___mul__(PByteSeq___len__(byteseq_5),
    int___unbox__(NO_OF_BITS_IN_BYTE()))))
  ensures issubtype(typeof(result), bool())
  ensures bool___unbox__(byteseq_bits_equal_until(byteseq_set_bit(byteseq_5,
    bit_3, int___unbox__(position_21)), byteseq_5, int___unbox__(position_21)))
  ensures bool___unbox__(result)
  decreases _
{
  (let byte_position_7 ==
    (__prim__int___box__(int___floordiv__(int___unbox__(position_21), int___unbox__(NO_OF_BITS_IN_BYTE())))) in
    (let bit_position_11 ==
      (__prim__int___box__(int___mod__(int___unbox__(position_21), int___unbox__(NO_OF_BITS_IN_BYTE())))) in
      (let floor_bit_position_0 ==
        (floor_align_byte(position_21)) in
        (asserting (int___eq__(bit_position_11, __prim__int___box__(int___sub__(int___unbox__(position_21),
          int___unbox__(floor_bit_position_0))))) in
          (let byte_15 ==
            (__prim__int___box__(PByteSeq___getitem__(byteseq_5, byte_position_7))) in
            (let new_seq_3 ==
              (@reveal()
              (byteseq_set_bit(byteseq_5, bit_3, int___unbox__(position_21)))) in
              (let new_byte_8 ==
                (__prim__int___box__(PByteSeq___getitem__(new_seq_3, byte_position_7))) in
                (let lemma_byte_equal_2 ==
                  (_lemma_byte_set_bit_equal(byte_15, bit_3, bit_position_11)) in
                  (let lemma_byte_2 ==
                    (__lemma_byte_set_bits_prefix(byte_15, bit_3, bit_position_11,
                    __prim__int___box__(1))) in
                    (let byte_prefix_0 ==
                      (byte_read_bits(int___unbox__(new_byte_8), 0, int___unbox__(bit_position_11))) in
                      (let old_byte_prefix_0 ==
                        (byte_read_bits(int___unbox__(byte_15), 0, int___unbox__(bit_position_11))) in
                        (let equal_0 ==
                          (@reveal()
                          (byteseq_bits_equal_until(new_seq_3, byteseq_5, int___unbox__(position_21)))) in
                          __prim__bool___box__(int___eq__(byte_prefix_0, old_byte_prefix_0) &&
                          bool___unbox__(equal_0))))))))))))))
}

@opaque()
function byteseq_set_bits(byteseq_6: Ref, value_5: Ref, position_22: Ref, length_9: Ref): Ref
  requires issubtype(typeof(byteseq_6), PByteSeq())
  requires issubtype(typeof(value_5), int())
  requires issubtype(typeof(position_22), int())
  requires issubtype(typeof(length_9), int())
  requires int___le__(__prim__int___box__(0), length_9) &&
    int___le__(length_9, NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), position_22) &&
    int___le__(__prim__int___box__(int___add__(int___unbox__(position_22), int___unbox__(length_9))),
    __prim__int___box__(int___mul__(PByteSeq___len__(byteseq_6), int___unbox__(NO_OF_BITS_IN_BYTE()))))
  requires int___le__(__prim__int___box__(0), value_5) &&
    int___lt__(value_5, int___lshift__(__prim__int___box__(1), length_9))
  ensures issubtype(typeof(result), PByteSeq())
  ensures int___eq__(length_9, __prim__int___box__(0)) ==>
    PByteSeq___eq__(result, byteseq_6)
  ensures int___eq__(__prim__int___box__(PByteSeq___len__(byteseq_6)), __prim__int___box__(PByteSeq___len__(result)))
  decreases int___unbox__(length_9)
{
  (let cond_11_0 ==
    (__prim__bool___box__(int___eq__(length_9, __prim__int___box__(0)))) in
    (true && bool___unbox__(cond_11_0) ?
      byteseq_6 :
      (let msb_1 ==
        (byte_read_bit(int___unbox__(value_5), int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
        int___unbox__(length_9)))) in
        (let rest_value_1 ==
          (byte_read_bits(int___unbox__(value_5), int___add__(int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
          int___unbox__(length_9)), 1), int___sub__(int___unbox__(length_9),
          1))) in
          (let new_seq_4 ==
            (byteseq_set_bit(byteseq_6, msb_1, int___unbox__(position_22))) in
            (let rec_0 ==
              (byteseq_set_bits(new_seq_4, rest_value_1, __prim__int___box__(int___add__(int___unbox__(position_22),
              1)), __prim__int___box__(int___sub__(int___unbox__(length_9),
              1)))) in
              rec_0))))))
}

@opaque()
function _lemma_byteseq_set_bits_equal(byteseq_7: Ref, value_6: Ref, position_23: Ref): Ref
  requires issubtype(typeof(byteseq_7), PByteSeq())
  requires issubtype(typeof(value_6), bool())
  requires issubtype(typeof(position_23), int())
  requires int___le__(__prim__int___box__(0), position_23) &&
    int___le__(__prim__int___box__(int___add__(int___unbox__(position_23), 1)),
    __prim__int___box__(int___mul__(PByteSeq___len__(byteseq_7), int___unbox__(NO_OF_BITS_IN_BYTE()))))
  ensures issubtype(typeof(result), bool())
  ensures PByteSeq___eq__(byteseq_set_bits(byteseq_7, value_6, position_23,
    __prim__int___box__(1)), byteseq_set_bit(byteseq_7, value_6, int___unbox__(position_23)))
  ensures bool___unbox__(result)
  decreases _
{
  (let bit_5 ==
    (@reveal()
    (byte_read_bit(int___unbox__(value_6), 7))) in
    (let repeated_2 ==
      (@reveal()
      (byteseq_set_bits(byteseq_7, value_6, position_23, __prim__int___box__(1)))) in
      (let single_10 ==
        (byteseq_set_bit(byteseq_7, value_6, int___unbox__(position_23))) in
        __prim__bool___box__(bool___eq__(bit_5, value_6) &&
        PByteSeq___eq__(repeated_2, single_10)))))
}

@opaque()
function __lemma_byteseq_set_bits_prefix(byteseq_8: Ref, value_7: Ref, position_24: Ref,
  length_10: Ref): Ref
  requires issubtype(typeof(byteseq_8), PByteSeq())
  requires issubtype(typeof(value_7), int())
  requires issubtype(typeof(position_24), int())
  requires issubtype(typeof(length_10), int())
  requires int___le__(__prim__int___box__(0), length_10) &&
    int___le__(length_10, NO_OF_BITS_IN_BYTE())
  requires int___le__(__prim__int___box__(0), position_24) &&
    int___le__(__prim__int___box__(int___add__(int___unbox__(position_24), int___unbox__(length_10))),
    __prim__int___box__(int___mul__(PByteSeq___len__(byteseq_8), int___unbox__(NO_OF_BITS_IN_BYTE()))))
  requires int___le__(__prim__int___box__(0), value_7) &&
    int___lt__(value_7, int___lshift__(__prim__int___box__(1), length_10))
  ensures issubtype(typeof(result), bool())
  ensures bool___unbox__(byteseq_bits_equal_until(byteseq_set_bits(byteseq_8,
    value_7, position_24, length_10), byteseq_8, int___unbox__(position_24)))
  ensures bool___unbox__(result)
  decreases int___unbox__(length_10)
{
  (let cond_12_0 ==
    (__prim__bool___box__(int___eq__(length_10, __prim__int___box__(0)))) in
    (true && bool___unbox__(cond_12_0) ?
      __prim__bool___box__(PByteSeq___eq__(byteseq_set_bits(byteseq_8, value_7,
      position_24, length_10), byteseq_8)) :
      (let full_4 ==
        (@reveal()
        (byteseq_set_bits(byteseq_8, value_7, position_24, length_10))) in
        (let msb_2 ==
          (byte_read_bit(int___unbox__(value_7), int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
          int___unbox__(length_10)))) in
          (let rest_value_2 ==
            (byte_read_bits(int___unbox__(value_7), int___add__(int___sub__(int___unbox__(NO_OF_BITS_IN_BYTE()),
            int___unbox__(length_10)), 1), int___sub__(int___unbox__(length_10),
            1))) in
            (let first_bit_seq_0 ==
              (byteseq_set_bit(byteseq_8, msb_2, int___unbox__(position_24))) in
              (let lemma_prefix_4 ==
                (__lemma_byteseq_set_bit_prefix(byteseq_8, msb_2, position_24)) in
                (let first_eq_byteseq_0 ==
                  (@reveal()
                  (byteseq_bits_equal_until(first_bit_seq_0, byteseq_8, int___unbox__(position_24)))) in
                  (let rest_seq_0 ==
                    (byteseq_set_bits(first_bit_seq_0, rest_value_2, __prim__int___box__(int___add__(int___unbox__(position_24),
                    1)), __prim__int___box__(int___sub__(int___unbox__(length_10),
                    1)))) in
                    (asserting (PByteSeq___eq__(full_4, rest_seq_0)) in
                      (let lemma_first_bit_seq_0 ==
                        (__lemma_byteseq_set_bits_prefix(first_bit_seq_0, rest_value_2,
                        __prim__int___box__(int___add__(int___unbox__(position_24),
                        1)), __prim__int___box__(int___sub__(int___unbox__(length_10),
                        1)))) in
                        (asserting (bool___unbox__(byteseq_bits_equal_until(rest_seq_0,
                          first_bit_seq_0, int___add__(int___unbox__(position_24),
                          1)))) in
                          (let lemma_prefix_induction_0 ==
                            (_lemma_byteseq_equal_prefix_induction(rest_seq_0,
                            first_bit_seq_0, __prim__int___box__(int___add__(int___unbox__(position_24),
                            1)))) in
                            (let rest_eq_first_0 ==
                              (@reveal()
                              (byteseq_bits_equal_until(rest_seq_0, first_bit_seq_0,
                              int___unbox__(position_24)))) in
                              (let full_eq_byteseq_0 ==
                                (@reveal()
                                (byteseq_bits_equal_until(full_4, byteseq_8,
                                int___unbox__(position_24)))) in
                                full_eq_byteseq_0)))))))))))))))
}

function __file__(): Ref
  decreases _


function __name__(): Ref
  decreases _


function NO_OF_BITS_IN_BYTE(): Ref
  ensures issubtype(typeof(result), int())
  ensures result == __prim__int___box__(8)
  decreases _
{
  __prim__int___box__(8)
}

function int___and__(self: Ref, other: Ref): Ref
  requires issubtype(typeof(self), int())
  requires issubtype(typeof(other), int())
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(self), bool()) ==> int___unbox__(self) >= -256)
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(self), bool()) ==> int___unbox__(self) <= 255)
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(other), bool()) ==> int___unbox__(other) >= -256)
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(other), bool()) ==> int___unbox__(other) <= 255)
  ensures issubtype(typeof(result), int())
  ensures result == int___and__(other, self)
  ensures result ==
    (issubtype(typeof(self), bool()) && issubtype(typeof(other), bool()) ?
      __prim__bool___box__(bool___unbox__(self) && bool___unbox__(other)) :
      __prim__int___box__(fromBVInt(andBVInt(toBVInt(int___unbox__(self)), toBVInt(int___unbox__(other))))))
  decreases _


function int___or__(self: Ref, other: Ref): Ref
  requires issubtype(typeof(self), int())
  requires issubtype(typeof(other), int())
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(self), bool()) ==> int___unbox__(self) >= -256)
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(self), bool()) ==> int___unbox__(self) <= 255)
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(other), bool()) ==> int___unbox__(other) >= -256)
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(other), bool()) ==> int___unbox__(other) <= 255)
  ensures issubtype(typeof(result), int())
  ensures result == int___or__(other, self)
  ensures result ==
    (issubtype(typeof(self), bool()) && issubtype(typeof(other), bool()) ?
      __prim__bool___box__(bool___unbox__(self) || bool___unbox__(other)) :
      __prim__int___box__(fromBVInt(orBVInt(toBVInt(int___unbox__(self)), toBVInt(int___unbox__(other))))))
  decreases _


function int___lshift__(self: Ref, other: Ref): Ref
  requires issubtype(typeof(self), int())
  requires issubtype(typeof(other), int())
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(self), bool()) ==>
    int___unbox__(other) <= 8 || int___unbox__(self) >= -256)
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(self), bool()) ==>
    int___unbox__(other) <= 8 || int___unbox__(self) <= 255)
  requires @error("Negative shift count.")
    (!issubtype(typeof(other), bool()) ==> int___unbox__(other) >= 0)
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(other), bool()) ==> int___unbox__(other) <= 255)
  decreases _
{
  __prim__int___box__((let shift_amt ==
    (int___unbox__(other)) in
    (let val ==
      (int___unbox__(self)) in
      (shift_amt == 0 ?
        val :
        (shift_amt == 1 ?
          val * 2 :
          (shift_amt == 2 ?
            val * 4 :
            (shift_amt == 3 ?
              val * 8 :
              (shift_amt == 4 ?
                val * 16 :
                (shift_amt == 5 ?
                  val * 32 :
                  (shift_amt == 6 ?
                    val * 64 :
                    (shift_amt == 7 ?
                      val * 128 :
                      (shift_amt == 8 ?
                        val * 256 :
                        (val >= 0 ?
                          fromBVInt(shlBVInt(toBVInt(val), toBVInt(shift_amt))) :
                          -fromBVInt(shlBVInt(toBVInt(-val), toBVInt(shift_amt))))))))))))))))
}

function int___rshift__(self: Ref, other: Ref): Ref
  requires issubtype(typeof(self), int())
  requires issubtype(typeof(other), int())
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(self), bool()) ==>
    int___unbox__(other) <= 8 || int___unbox__(self) >= -256)
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(self), bool()) ==>
    int___unbox__(other) <= 8 || int___unbox__(self) <= 255)
  requires @error("Negative shift count.")
    (!issubtype(typeof(other), bool()) ==> int___unbox__(other) >= 0)
  requires @error("Bitwise operations on ints can only be performed in the range set by the --int-bitops-size setting (default: 8 bits).")
    (!issubtype(typeof(other), bool()) ==> int___unbox__(other) <= 255)
  decreases _
{
  __prim__int___box__((let shift_amt ==
    (int___unbox__(other)) in
    (let val ==
      (int___unbox__(self)) in
      (shift_amt == 0 ?
        val :
        (shift_amt == 1 ?
          val \ 2 :
          (shift_amt == 2 ?
            val \ 4 :
            (shift_amt == 3 ?
              val \ 8 :
              (shift_amt == 4 ?
                val \ 16 :
                (shift_amt == 5 ?
                  val \ 32 :
                  (shift_amt == 6 ?
                    val \ 64 :
                    (shift_amt == 7 ?
                      val \ 128 :
                      (shift_amt == 8 ?
                        val \ 256 :
                        (val >= 0 ?
                          fromBVInt(shrBVInt(toBVInt(val), toBVInt(shift_amt))) :
                          -fromBVInt(shrBVInt(toBVInt(-val), toBVInt(shift_amt))))))))))))))))
}

function int___bool__(self: Ref): Bool
  requires self != null ==> issubtype(typeof(self), int())
  ensures self == null ==> !result
  ensures self != null ==> result == (int___unbox__(self) != 0)
  decreases _


function __prim__int___box__(prim: Int): Ref
  ensures typeof(result) == int()
  ensures int___unbox__(result) == prim
  decreases _


function int___unbox__(box: Ref): Int
  requires issubtype(typeof(box), int())
  ensures !issubtype(typeof(box), bool()) ==>
    __prim__int___box__(result) == box
  ensures issubtype(typeof(box), bool()) ==>
    __prim__bool___box__(result != 0) == box
  ensures (forall i: Ref ::
      { object___eq__(box, i), int___unbox__(i) }
      object___eq__(box, i) && issubtype(typeof(i), int()) ==>
      int___unbox__(i) == result)
  decreases _


function __prim__bool___box__(prim: Bool): Ref
  ensures typeof(result) == bool()
  ensures bool___unbox__(result) == prim
  ensures int___unbox__(result) == (prim ? 1 : 0)
  decreases _


function bool___unbox__(box: Ref): Bool
  requires issubtype(typeof(box), bool())
  ensures __prim__bool___box__(result) == box
  decreases _


function int___eq__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), int())
  requires issubtype(typeof(other), int()) ||
    issubtype(typeof(other), float())
  ensures issubtype(typeof(other), int()) ==>
    result == (int___unbox__(self) == int___unbox__(other))
  ensures issubtype(typeof(other), int()) ==>
    result == object___eq__(self, other)
  ensures issubtype(typeof(other), float()) ==>
    result == float___eq__(self, other)
  decreases _


function bool___eq__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), bool())
  requires issubtype(typeof(other), bool())
  ensures result == (bool___unbox__(self) == bool___unbox__(other))
  ensures result == object___eq__(self, other)
  decreases _


function int___ge__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), int())
  requires issubtype(typeof(other), float())
  decreases _
{
  (issubtype(typeof(other), int()) ?
    int___unbox__(self) >= int___unbox__(other) :
    float___ge__(self, other))
}

function int___gt__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), int())
  requires issubtype(typeof(other), float())
  decreases _
{
  (issubtype(typeof(other), int()) ?
    int___unbox__(self) > int___unbox__(other) :
    float___gt__(self, other))
}

function int___le__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), int())
  requires issubtype(typeof(other), float())
  decreases _
{
  (issubtype(typeof(other), int()) ?
    int___unbox__(self) <= int___unbox__(other) :
    float___le__(self, other))
}

function int___lt__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), int())
  requires issubtype(typeof(other), float())
  decreases _
{
  (issubtype(typeof(other), int()) ?
    int___unbox__(self) < int___unbox__(other) :
    float___lt__(self, other))
}

function int___add__(self: Int, other: Int): Int
  decreases _
{
  self + other
}

function int___sub__(self: Int, other: Int): Int
  decreases _
{
  self - other
}

function int___mul__(self: Int, other: Int): Int
  decreases _
{
  self * other
}

function int___floordiv__(self: Int, other: Int): Int
  requires @error("Divisor may be zero.")
    (other != 0)
  decreases _
{
  self \ other
}

function int___mod__(self: Int, other: Int): Int
  requires other != 0
  decreases _
{
  self % other
}

function int___invert__(self: Ref): Ref
  requires issubtype(typeof(self), int())
  ensures result == __prim__int___box__(-(1 + int___unbox__(self)))
  decreases _


function int___int__(self: Ref): Ref
  requires issubtype(typeof(self), int())
  ensures result == self
  decreases _


function int___byte_bounds__(value: Int): Bool
  decreases _
{
  0 <= value && value < 256
}

function float___ge__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), float())
  requires issubtype(typeof(other), float())
  ensures issubtype(typeof(self), int()) && issubtype(typeof(other), int()) ==>
    result == int___ge__(self, other)
  decreases _


function float___gt__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), float())
  requires issubtype(typeof(other), float())
  ensures issubtype(typeof(self), int()) && issubtype(typeof(other), int()) ==>
    result == int___gt__(self, other)
  decreases _


function float___le__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), float())
  requires issubtype(typeof(other), float())
  ensures issubtype(typeof(self), int()) && issubtype(typeof(other), int()) ==>
    result == int___le__(self, other)
  decreases _


function float___lt__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), float())
  requires issubtype(typeof(other), float())
  ensures issubtype(typeof(self), int()) && issubtype(typeof(other), int()) ==>
    result == int___lt__(self, other)
  decreases _


function float___eq__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), float())
  requires issubtype(typeof(other), float())
  ensures issubtype(typeof(self), int()) && issubtype(typeof(other), int()) ==>
    result == int___eq__(self, other)
  decreases _


function Level(r: Ref): Perm
  decreases _


function PByteSeq___val__(self: Ref): Seq[Int]
  requires issubtype(typeof(self), PByteSeq())
  ensures (forall i: Int ::
      { (i in result) }
      (i in result) ==> int___byte_bounds__(i))
  decreases _


function PByteSeq___len__(self: Ref): Int
  requires issubtype(typeof(self), PByteSeq())
  ensures result == |PByteSeq___val__(self)|
  decreases _


function PByteSeq___create__(values: Seq[Int]): Ref
  requires (forall i: Int ::
      { (i in values) }
      (i in values) ==> int___byte_bounds__(i))
  ensures typeof(result) == PByteSeq()
  ensures PByteSeq___val__(result) == values
  decreases _


function PByteSeq___getitem__(self: Ref, index: Ref): Int
  requires issubtype(typeof(self), PByteSeq())
  requires issubtype(typeof(index), int())
  requires @error("Index may be out of bounds.")
    ((let ln ==
      (PByteSeq___len__(self)) in
      @error("Index may be out of bounds.")
      ((int___unbox__(index) < 0 ==> int___unbox__(index) >= -ln) &&
      (int___unbox__(index) >= 0 ==> int___unbox__(index) < ln))))
  ensures result ==
    (int___unbox__(index) >= 0 ?
      PByteSeq___val__(self)[int___unbox__(index)] :
      PByteSeq___val__(self)[PByteSeq___len__(self) + int___unbox__(index)])
  ensures int___byte_bounds__(result)
  decreases _


function PByteSeq_take(self: Ref, no: Int): Ref
  requires issubtype(typeof(self), PByteSeq())
  ensures result == PByteSeq___create__(PByteSeq___val__(self)[..no])
  decreases _


function PByteSeq_update(self: Ref, index: Int, val: Int): Ref
  requires issubtype(typeof(self), PByteSeq())
  requires index >= 0 && index < PByteSeq___len__(self)
  ensures int___byte_bounds__(val)
  ensures result ==
    PByteSeq___create__(PByteSeq___val__(self)[index := val])
  decreases _


function PByteSeq___eq__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), PByteSeq())
  requires issubtype(typeof(other), PByteSeq())
  ensures result == (PByteSeq___val__(self) == PByteSeq___val__(other))
  ensures result ==> self == other
  ensures result == object___eq__(self, other)
  decreases _


function str___len__(self: Ref): Int
  ensures result >= 0
  decreases _


function str___val__(self: Ref): Seq[Int]
  decreases _


function str___create__(len: Int, value: Seq[Int]): Ref
  ensures str___len__(result) == len
  ensures str___val__(result) == value
  ensures typeof(result) == str()
  decreases _


function str___eq__(self: Ref, other: Ref): Bool
  requires issubtype(typeof(self), str())
  ensures (str___val__(self) == str___val__(other)) == result
  ensures result ==> str___len__(self) == str___len__(other)
  ensures result == object___eq__(self, other)
  decreases _


predicate MustInvokeBounded(r: Ref) 

predicate MustInvokeUnbounded(r: Ref) 

predicate _MaySet(rec: Ref, id: Int) 

method _lemma_byteseq_equal_implies_read_bit(b1_2: Ref, b2_2: Ref, end_2: Ref,
  position_25: Ref)
  returns (_res: Ref)
  requires issubtype(typeof(b1_2), PByteSeq())
  requires issubtype(typeof(b2_2), PByteSeq())
  requires issubtype(typeof(end_2), int())
  requires issubtype(typeof(position_25), int())
  requires int___le__(__prim__int___box__(PByteSeq___len__(b1_2)), __prim__int___box__(PByteSeq___len__(b2_2)))
  requires int___le__(__prim__int___box__(0), end_2) &&
    int___le__(end_2, __prim__int___box__(int___mul__(PByteSeq___len__(b1_2),
    int___unbox__(NO_OF_BITS_IN_BYTE()))))
  requires int___le__(__prim__int___box__(0), position_25) &&
    int___lt__(position_25, end_2)
  requires bool___unbox__(byteseq_bits_equal_until(b1_2, b2_2, int___unbox__(end_2)))
  ensures issubtype(typeof(_res), bool())
  ensures bool___eq__(byteseq_read_bit(b1_2, int___unbox__(position_25)), byteseq_read_bit(b2_2,
    int___unbox__(position_25)))
  ensures bool___unbox__(_res)
{
  var _err: Ref
  var byteseq_eq: Ref
  var end_byte_position: Ref
  var end_bit_position: Ref
  var byte_position_3: Ref
  var bit_position_5: Ref
  var val1: Ref
  var val2: Ref
  var byte1_2: Ref
  var byte2_2: Ref
  var lemma: Ref
  var b1_3: Ref
  var b2_3: Ref
  var end_3: Ref
  var position_26: Ref
  _res := null
  _err := null
  b1_3 := b1_2
  b2_3 := b2_2
  end_3 := end_2
  position_26 := position_25
  byteseq_eq := @reveal()
    (byteseq_bits_equal_until(b1_3, b2_3, int___unbox__(end_3)))
  inhale _isDefined(535497411105366843095394)
  end_byte_position := __prim__int___box__(int___floordiv__(int___unbox__(end_3),
    int___unbox__(NO_OF_BITS_IN_BYTE())))
  inhale _isDefined(37579152221119699384916279005206410456677)
  end_bit_position := __prim__int___box__(int___mod__(int___unbox__(end_3),
    int___unbox__(NO_OF_BITS_IN_BYTE())))
  inhale _isDefined(146793563363748825722333424795276045925)
  byte_position_3 := __prim__int___box__(int___floordiv__(int___unbox__(position_26),
    int___unbox__(NO_OF_BITS_IN_BYTE())))
  inhale _isDefined(266742718275822727789435493442419042)
  bit_position_5 := __prim__int___box__(int___mod__(int___unbox__(position_26),
    int___unbox__(NO_OF_BITS_IN_BYTE())))
  inhale _isDefined(1082528562472235871275376899811682)
  val1 := @reveal()
    (byteseq_read_bit(b1_3, int___unbox__(position_26)))
  inhale _isDefined(829186422)
  val2 := @reveal()
    (byteseq_read_bit(b2_3, int___unbox__(position_26)))
  inhale _isDefined(845963638)
  if (int___eq__(_checkDefined(byte_position_3, 266742718275822727789435493442419042),
  _checkDefined(end_byte_position, 37579152221119699384916279005206410456677)) &&
  int___gt__(_checkDefined(end_bit_position, 146793563363748825722333424795276045925),
  __prim__int___box__(0))) {
    byte1_2 := __prim__int___box__(PByteSeq___getitem__(b1_3, _checkDefined(byte_position_3,
      266742718275822727789435493442419042)))
    inhale _isDefined(14178414595701090)
    byte2_2 := __prim__int___box__(PByteSeq___getitem__(b2_3, _checkDefined(byte_position_3,
      266742718275822727789435493442419042)))
    inhale _isDefined(14178418890668386)
    assert int___eq__(byte_read_bits(int___unbox__(_checkDefined(byte1_2, 14178414595701090)),
      0, int___unbox__(_checkDefined(end_bit_position, 146793563363748825722333424795276045925))),
      byte_read_bits(int___unbox__(_checkDefined(byte2_2, 14178418890668386)),
      0, int___unbox__(_checkDefined(end_bit_position, 146793563363748825722333424795276045925))))
    lemma := _lemma_byte_prefix_implies_read_bit(_checkDefined(byte1_2, 14178414595701090),
      _checkDefined(byte2_2, 14178418890668386), _checkDefined(end_bit_position,
      146793563363748825722333424795276045925), _checkDefined(bit_position_5,
      1082528562472235871275376899811682))
    inhale _isDefined(418447713644)
    assert bool___eq__(byte_read_bit(int___unbox__(_checkDefined(byte1_2, 14178414595701090)),
      int___unbox__(_checkDefined(bit_position_5, 1082528562472235871275376899811682))),
      byte_read_bit(int___unbox__(_checkDefined(byte2_2, 14178418890668386)),
      int___unbox__(_checkDefined(bit_position_5, 1082528562472235871275376899811682))))
    _res := __prim__bool___box__(bool___eq__(_checkDefined(val1, 829186422),
      _checkDefined(val2, 845963638)))
    goto __end
  }
  inhale false
  byte1_2 := __prim__int___box__(PByteSeq___getitem__(b1_3, _checkDefined(byte_position_3,
    266742718275822727789435493442419042)))
  inhale _isDefined(14178414595701090)
  byte2_2 := __prim__int___box__(PByteSeq___getitem__(b2_3, _checkDefined(byte_position_3,
    266742718275822727789435493442419042)))
  inhale _isDefined(14178418890668386)
  assert int___eq__(_checkDefined(byte1_2, 14178414595701090), _checkDefined(byte2_2,
    14178418890668386))
  _res := __prim__bool___box__(bool___eq__(_checkDefined(val1, 829186422), _checkDefined(val2,
    845963638)))
  goto __end
  goto __end
  label __end
}

method main()
{
  var module_defined_0: Bool
  var module_names_0: Set[_Name]
  module_defined_0 := true
  module_names_0 := Set[_Name]()
  module_names_0 := (module_names_0 union
    Set(_single(6872323072689856351)))
  inhale acc(__file__()._val, 99 / 100) &&
    issubtype(typeof(__file__()._val), str()) &&
    issubtype(typeof(__file__()._val), str())
  module_names_0 := (module_names_0 union
    Set(_single(6872323076851130207)))
  inhale acc(__name__()._val, 99 / 100) &&
    issubtype(typeof(__name__()._val), str()) &&
    issubtype(typeof(__name__()._val), str()) &&
    str___eq__(str___create__(8, Seq(95, 95, 109, 97, 105, 110, 95, 95)), __name__()._val)
  module_names_0 := (module_names_0 union Set(_single(465491093830)))
  module_names_0 := (module_names_0 union Set(_single(435611006292)))
  module_names_0 := (module_names_0 union Set(_single(474315583061)))
  module_names_0 := (module_names_0 union
    Set(_single(7809644653626814543)))
  module_names_0 := (module_names_0 union Set(_single(1953720652)))
  module_names_0 := (module_names_0 union Set(_single(7958081)))
  module_names_0 := (module_names_0 union
    Set(_single(7308324465885864259)))
  inhale NO_OF_BITS_IN_BYTE() == __prim__int___box__(8)
  module_names_0 := (module_names_0 union
    Set(_single(6039450094029064787029486808194059673227086)))
  module_names_0 := (module_names_0 union
    Set(_single(134856795975323057539871314672186518630)))
  module_names_0 := (module_names_0 union
    Set(_single(680512731850514063370037404267656463643033122148093426694498)))
  module_names_0 := (module_names_0 union
    Set(_single(2658252858791070560039208610420551142622374808200416622946)))
  module_names_0 := (module_names_0 union
    Set(_single(54921992499979810399013061278754872047215149929430078143365248210741333335534240671296607)))
  module_names_0 := (module_names_0 union
    Set(_single(9223081702892735048061948295522)))
  module_names_0 := (module_names_0 union
    Set(_single(2341700186122834833801995846187362)))
  module_names_0 := (module_names_0 union
    Set(_single(174161067341133809685358273844441427341457351630367822377741407)))
  module_names_0 := (module_names_0 union
    Set(_single(883395723920305327863783087788338690415656224253332828969927942167812398007066127455)))
  module_names_0 := (module_names_0 union
    Set(_single(195122114021656793166716636419157459427436351815694368642713042038666128479)))
  module_names_0 := (module_names_0 union
    Set(_single(3569337465892209406533793875557746790807403820198352897539826945822403367165848671)))
  module_names_0 := (module_names_0 union
    Set(_single(154737633915079240732109049116138699106)))
  module_names_0 := (module_names_0 union
    Set(_single(57894222162841129966880888441296564415080377627681959114565467889447661246289350186331231)))
  module_names_0 := (module_names_0 union
    Set(_single(39287209829823002539020188903769483016546)))
  module_names_0 := (module_names_0 union
    Set(_single(748016088466623364694787233656569482831119258577814724295061894037072991)))
  module_names_0 := (module_names_0 union
    Set(_single(12534248059662103198691370210274658578381604245140171083889348081260357999948191296332852319)))
  module_names_0 := (module_names_0 union
    Set(_single(36027662903078808997665732962)))
  module_names_0 := (module_names_0 union
    Set(_single(9147266352043477632255220021602)))
  module_names_0 := (module_names_0 union
    Set(_single(191492118647455493507829928489209189441320483818120754825069156144868253535)))
  module_names_0 := (module_names_0 union
    Set(_single(49021982373748606325301321400468642366820077470066765146939576490971783520095)))
  module_names_0 := (module_names_0 union
    Set(_single(680316669301303944083430840363832021908910603644209457359967)))
  module_names_0 := (module_names_0 union
    Set(_single(12680834039330368801202137448044647065097249343822033373196744154975)))
  module_names_0 := (module_names_0 union
    Set(_single(41737682140297122683020571951962904967855173651461281893728411487)))
  module_names_0 := (module_names_0 union
    Set(_single(12680834045681317665464293231242579335675721283710016809111000997727)))
  module_names_0 := (module_names_0 union
    Set(_single(659130005352346914348386437550902513478641478751)))
  module_names_0 := (module_names_0 union
    Set(_single(604443882500140243579942679036066146)))
  module_names_0 := (module_names_0 union
    Set(_single(2735320736746512323809571725418145519967388645496194927865446745792351)))
  module_names_0 := (module_names_0 union
    Set(_single(831051139601555049847238415317028294638207364981794807503499886511021919)))
  module_names_0 := (module_names_0 union
    Set(_single(153465663397765465627517754611275692386)))
  module_names_0 := (module_names_0 union
    Set(_single(2921937845572747518339012632866150757587344931531581361069906542816351)))
  module_names_0 := (module_names_0 union
    Set(_single(212749091737998092737429319627533821454964616098903863136777783793505034079)))
  goto __end
  label __end
}
